\chapter{Escalonamento de tarefas com penalidades de antecipação e atraso} \label{chap-ProbEscalET}

Neste capítulo é abordada a classe de problemas de principal interesse deste trabalho, envolvendo problemas de escalonamento de tarefas com penalidades de antecipação e atraso. Para isto, cada tipo de penalidade - antecipação ou atraso - é considerada em separado e depois em conjunto. São apresentadas as definições e conceitos principais, notação clássica e exemplos de aplicação, bem como uma revisão da literatura tanto para ambiente monoprocessado quanto para máquinas paralelas. Questões estruturais de escalonamentos válidos são analisadas, destacando-se uma análise sobre soluções diferentes com empate no valor da função objetivo e soluções com simetria. Por fim, uma análise das formulações matemáticas disponíveis na literatura para o problema também é apresentada.

Na literatura existe uma ampla e crescente quantidade de trabalhos que consideram problemas de escalonamento com antecipação e atraso, dentre eles destacam-se as revisões da literatura apresentadas por Baker e Scudder~\cite{baker:1990}, Gordon et al.~\cite{Gordon20021} e Shabtay e Steiner~\cite{ShabtaySteiner:2012}. Este capítulo foi estruturado com base na análise realizada sobre o problema, e os trabalhos e resultados encontrados.


\section{Escalonamento com atraso de tarefas} \label{sec:T}

Minimizar o atraso total de uma tarefa é uma das considerações mais importantes na produção industrial, onde se trabalha com datas de entrega contratuais. Na literatura, existem diversos trabalhos propondo modelos teóricos diferenciados e novos métodos de resolução. As principais abordagens exatas para este problema são, em sua maioria, baseadas em algoritmos de Programação Dinâmica e \textit{branch-and-bound}, mas, os melhores resultados para o problema clássico em máquinas paralelas envolvem um método de \emph{branch-cut-and-price}~\cite{ArturEduardoMarcusRosiane:2010}. Abordagens aproximadas são baseadas em regras de despacho ou políticas de escalonamento de tarefas, embutidas em heurísticas e meta-heurísticas. 

A Figura~\ref{fig:tardiness} mostra a definição do atraso de uma tarefa na linha do tempo, onde a mudança da curva ocorre no ponto definido pela data de término sugerida (\emph{due date}, $d_{j},$). Pode-se observar que antes da data de término sugerida $d_{j},$ o valor de atraso é nulo e, após essa data, o valor de atraso é monotonicamente crescente. A Tabela~\ref{table:classificacao-WT} apresenta uma classificação dos problemas de escalonamento de tarefas com atraso, investigados nesta seção.

\begin{figure}[ht]
\centering
\includegraphics[width=.55\textwidth]{imagens/tardiness}
\caption{Definição do valor de atraso na linha do tempo.}
\label{fig:tardiness}
\end{figure}

\subsection{Ambiente monoprocessado com atraso de tarefas}
O problema $1 || \sum {T_{j}}$ recebeu bastante atenção na literatura pois durante muitos anos sua complexidade permaneceu em aberto, até que o mesmo foi provado como NP-difícil em 1990 por Du e Leung~\cite{Du:1990:MTT:92217.92229}. Abordagens exatas para este problema são, em sua maioria, baseadas em algoritmos de programação dinâmica e \textit{branch-and-bound}. Abordagens aproximadas são baseadas em regra de despacho ou políticas de escalonamento de tarefas, embutida em heurísticas e meta-heurísticas. 

Tan e Narasimhan~\cite{TanandNarasimhan:1997} propuseram um algoritmo de recozimento simulado (\textit{simulated annealing}). Abordagens utilizando algoritmos genéticos também podem ser encontradas em Liu et al.~\cite{Liu:2005} e Demirel et al.~\cite{Demirel:2011}, bem como quando adicionado ao problema clássico acima, tempos de preparação (\textit{setups}) (Tan et al.~\cite{Tan:2000} e França et al.~\cite{Franca:2001}). Alguns trabalhos apresentam estratégias híbridas como em Feili~\cite{Feili:2011}, onde são propostos três estratégias algorítmicas para o problema de escalonamento com atraso ponderado de tarefas baseado em recozimento simulado, algoritmo genético e busca local.

Estratégias eficientes de busca em vizinhança baseada em movimentos generalizados de troca de pares são apresentados em Rodrigues et al.~\cite{RosianeArthurEduardoMarcus:2008} e Grosso et. al.~\cite{Grosso:2004}. Gupta e Smith~\cite{GuptaS06} propuseram um algoritmo GRASP com reconexão de caminhos e um algoritmo de Busca Local para a minimização do atraso ponderado de tarefas com tempos de preparação. Outro método de busca foi apresentado por Mendes et al.~\cite{Mendes:2002}, envolvendo busca múltipla (\textit{multi-start}), que trata-se de um algoritmo que parte de várias soluções iniciais aleatórias seguidas de busca local a fim de encontrar uma solução ótima na vizinhança do espaço de soluções.

Trabalhos que consideram estratégias exatas baseadas em Programação Dinâmica foram considerados em Baptiste~\cite{Baptiste:2000} e Tanaka e Fujikuma~\cite{TanakaFujikuma:2011}. Métodos de \textit{branch-and-bound} foram considerados em Wodecki~\cite{Wodecki:2008}, Babu~\cite{BabuPP04} e Lu e Chu~\cite{luo:a}, incluindo resultados para $40$ e $50$ tarefas.

Tian et al.~\cite{Tian:2006} forneceram um algoritmo de tempo $O(n^{2})$ para solucionar o problema $1 | r_{j}, p_{j} = p, pmtn | \sum{T_{j}}$,envolvendo janelas de tempo, preempção e tempos iguais de processamento, usando o conceito de blocos (técnica de decomposição), onde o problema de escalonamento é decomposto em dois subproblemas e cada subproblema envolvendo um escalonamento ótimo, que é então distribuído para cada bloco. Finalmente, é investigado o escalonamento de um bloco com tarefas de tempos iguais e algumas propriedades são derivadas para a elaboração de um algoritmo para solucionar o problema.


\subsection{Máquinas paralelas com atraso de tarefas}
Uma abordagem sumarizada para os problemas de escalonamento em máquinas paralelas e uma exposição sobre suas complexidades pode ser consultada em Kravchenko e Werner~\cite{Kravchenko:2011}.
Nesta subseção, para se discorrer sobre os problemas de escalonamento em máquinas paralelas, são considerados os três tipos clássicos de ambientes, onde em todos eles, cada tarefa pode ser processada em qualquer uma das $m$ máquinas. Tais ambientes podem envolver: \textit{Máquinas paralelas idênticas} $(P)$, onde os tempos de processamento independem da máquina, ou seja, $p_{ij} = p_{j}$; \textit{Máquinas paralelas uniformes} $(Q)$ onde cada máquina possui um desempenho/velocidade diferente, onde $p_{ij} = p_{j}  / \tau_{i}$ e $\tau_{i}$ denota a velocidade uniforme da máquina $M_{i}$ e; \textit{Máquinas paralelas não-relacionadas} $(R)$ onde cada máquina tem um comportamento/velocidade diferente para cada tarefa.


\subsubsection{Máquinas paralelas idênticas}

Considere um problema de escalonamento em máquinas paralelas que inclui um conjunto de tarefas independentes, $J = \{J_1, J_2, ..., J_n\}$, em um conjunto de máquinas paralelas idênticas, $P = \{1, 2, ..., m\}$, minimizando uma função objetivo como o atraso total ponderado.

Armentano e Yamashita~\cite{Armentano:2000} consideraram o algoritmo de \textbf{busca tabu} para escalonar as tarefas em máquinas paralelas idênticas com o objetivo de minimizar o atraso. A abordagem dos autores inicia com uma solução obtida pela heurística KPM, que por sua vez pode ser descrita em dois passos: no primeiro passo, todas as tarefas não escalonadas são listadas usando a política de escalonamento do menor para o maior tempo de processamento (\textit{shortest processing time first} - SPT) e geram-se $m$ cópias desta lista - uma para cada máquina. No segundo passo, determina-se a próxima tarefa a ser escalonada usando a heurística PSK (desenvolvida por Panwalkar et al.~\cite{Panwalkar1993304}) para minimizar o atraso total em uma máquina única. 

Após a solução gerada pela heurística KPM, Armentano e Yamashita~\cite{Armentano:2000} aplicaram a busca tabu nas soluções vizinhas para obter novas e melhores soluções, sendo a vizinhança definida por dois movimentos. O primeiro envolve inserções que consistem em transferir cada tarefa de uma máquina para outra e a segunda envolve trocas, que são obtidas pelas trocas de pares de tarefas de duas máquinas.

Existem na literatura abordagens para o ambiente de máquinas paralelas idênticas, mas que também consideram o ambiente monoprocessado, como pode ser observado em Rodrigues et al.~\cite{RosianeArthurEduardoMarcus:2008}, onde foi proposto um algoritmo heurístico para o problema $P || \sum{w_{j}T_{j}}$ em que o escalonamento tanto uma máquina quanto em máquinas paralelas é representado por uma lista sequencial de tarefas (Figura~\ref{fig:Single-Gantt-chart} (a)). A Figura~\ref{fig:Single-Gantt-chart} (b) mostra representação de um escalonamento em máquinas paralelas idênticas através do \textbf{gráfico de Gantt}. 

Para este mesmo problema de escalonamento (considerando somente máquinas paralelas idênticas), Croce et al.~\cite{DellaCroce2012} apresentaram uma heurística de melhoria cujos resultados computacionais apresentados são melhores que os resultados existentes na literatura, incluindo os apresentados por Rodrigues et al.~\cite{RosianeArthurEduardoMarcus:2008}. Um algoritmo exato pode ser consultado em Pessoa et al.~\cite{ArturEduardoMarcusRosiane:2010}, onde foi proposto um método \textit{branch-cut-and-price} para o problema $P || \sum{w_{j}T_{j}}$, considerando o ambiente monoprocessado, além de máquinas paralelas idênticas.

Kravchenko e Werner~\cite{kravchenko:2009} mostraram que os problemas $ P | pmtn |\sum{T_{j}} $, com preempções permitidas, e $ P | r_{j}, p_{j} = p, pmtn |\sum{T_{j}} $, com datas de chegada definidas, tarefas de tempos de processamento iguais e preempções permitidas, são NP-difíceis.


\subsubsection{Máquinas paralelas uniformes}

Considere um problema de escalonamento em máquinas paralelas que inclui um conjunto de tarefas independentes, $J = \{J_1, J_2, ..., J_n\}$, em um conjunto de máquinas paralelas uniformes ou com velocidades diferentes, $Q = \{1, 2, ..., m\}$, minimizando uma função objetivo como o atraso total ponderado.

Dessouky et al.~\cite{Dessouky:1990} consideraram o caso de escalonar $n$ tarefas idênticas em $m$ máquinas paralelas uniformes, problema $Q |p_{j} = 1| \sum{T_{j}}$, onde foram propostos algoritmos polinomiais de tempo $O(n \log n)$ para minimizar o atraso total ponderado e a latência máxima. O problema foi solucionado através de um algoritmo de trocas ou alocação simples, que consiste em organizar as tarefas em ordem não-decrescente de datas de término e associá-las de acordo com os tempos de completude $C_1, ..., C_n$.

Kravchenko e Werner~\cite{kravchenko:2009} consideraram o caso onde preempções são permitidas, ou seja, o tempo de processamento de qualquer tarefa pode ser interrompido a qualquer instante e recomeçar depois, possivelmente em uma máquina diferente. Foram desenvolvidos algoritmos de tempo polinomial para os problemas $Q | p_{j} = p, pmtn | \sum{T_{j}}$ e $Q | p_{j} = p, pmtn | \sum{T_{j}}$.

Dourado et al.~\cite{MitreRodriguesSzwarcfiter:2010} apresentaram algoritmos para os problemas de escalonamento $Q |p_{j} = 1| \sum{w_{j}T_{j}} $ e $Q |p_{j} = p| \sum{w_{j}T_{j}} $, onde é dado um conjunto $J = \{ J_{1}, ..., J_{n} \}$ de $n$ tarefas a serem escalonadas em $m$ máquinas paralelas uniformes $Q = \{ Q_{1}, ..., Q_{m} \}$, onde cada máquina $Q_i$ tem uma velocidade específica $q_i$ e toda tarefa $J_j$ tem um tempo de processamento $p_j = p$. A execução da tarefa $J_j$ na máquina $Q_i$ requer tempo $p_{j}/q_{j}$. Para o problema $Q |p_{j} = 1| \sum{w_{j}T_{j}} $, a estratégia utilizada para resolver o problema envolve primeiramente solucionar uma versão não ponderada do problema ($Q | p_{j} = 1 | \sum{T_{j}}$), resultando em um escalonamento com bipartição de tarefas (tarefas finalizadas em suas datas de término sugeridas e tarefas com atraso). Uma estratégia ótima para o caso ponderado é obtida através da troca das tarefas tardias com as tarefas finalizadas em suas datas de término sugeridas. Desta forma, essa mesma estratégia pode ser utilizada para o problema $Q |p_{j} = p| \sum{w_{j}T_{j}} $, por ser um problema equivalente ao problema $Q |p_{j} = 1| \sum{w_{j}T_{j}} $.


\subsubsection{Máquinas paralelas não-relacionadas}

Considere um problema de escalonamento em máquinas paralelas que inclui um conjunto de tarefas independentes, $J = \{J_1, J_2, ..., J_n\}$, em um conjunto de máquinas paralelas não-relacionadas, $R = \{1, 2, ..., m\}$, onde cada tarefa possui um desempenho associado a cada máquina, com o objetivo de minimizar uma função objetivo como o atraso total ponderado.

Bilyk e Mönch~\cite{Bilyk:2010} estudaram um problema de planejamento e escalonamento em máquinas paralelas não relacionadas. Foram consideradas $n$ tarefas que devem ser atribuídas e escalonadas em $m$ máquinas paralelas não relacionadas, sendo que cada tarefa possui um peso que representa a prioridade do pedido do cliente correspondente, uma data de término sugerida e uma data de chegada. Foi modelado um problema de escalonamento em máquinas paralelas não relacionadas em um ambiente de fabricação de placas de fiação impressa (PWB), que consiste em múltiplos estágios de produção, no qual cada placa deve passar por uma sequência pré-determinada de passos de fabricação. Para resolver este problema foi desenvolvida uma metodologia heurística baseada em decomposição e busca em vizinhanças variáveis (\textit{variable neighborhood search} - VNS).


\begin{table}[htpb]
% title of Table
\centering
\caption{Classificação dos problemas de escalonamento com atraso de tarefas.}
\scalefont{0.79}
% used for centering table
\begin{tabular}{c|p{3.5cm}|p{5cm}|p{3cm}}
\hline
 \multicolumn{1}{c|}{\textbf{Ambiente}} & \multicolumn{1}{c|}{\textbf{Problemas}} & \multicolumn{1}{c|}{\textbf{Estratégias de resolução}} &  \multicolumn{1}{c}{\textbf{Referências}} \\
\hline
 \multirow{29}{*}{$\textbf{1}$} & $ 1 |ST_{sd}| \sum{T_{j}}$, onde $ST_{sd}$ refere-se ao tempo de preparação dependente da sequência  & Recozimento simulado & Tan e Narasimhan~\cite{TanandNarasimhan:1997} \\ \cline{2-4}
                                & $ 1 |ST_{sd}| \sum{T_{j}}$  & \textit{Branch-and-bound}, \textit{simulated annealing}, algoritmo genético e técnica de troca de pares (\textit{pairwise interchange}) & Tan et
                                al.~\cite{Tan:2000} \\ \cline{2-4}
                                & $ 1 | s_{ij} | \sum{T_{j}}$  &  \textit{Branch-and-bound}  & Lu e Chu~\cite{luo:a} \\ \cline{2-4}
                                & $ 1 || \sum{w_{j}T_{j}}$  & \textit{Branch-and-bound}  &  Babu~\cite{BabuPP04}, Wodecki~\cite{Wodecki:2008} \\ \cline{2-4}
                                & $ 1 |ST_{sd}| \sum{T_{j}}$  & Algoritmo genético & França et al.~\cite{Franca:2001} \\  \cline{2-4}
                                & $ 1 |s_{ij}| \sum{w_{j}T_{j}}$  & GRASP com reconexão de caminhos e busca local & Gupta e Smith~\cite{GuptaS06} \\  \cline{2-4}
                                & $ 1 || \sum{w_{j}T_{j}}$  & Algoritmo genético & Liu et al.~\cite{Liu:2005} \\  \cline{2-4}
                                & $ 1 || \sum{T_{j}}$  & Algoritmo genético & Demirel et al.~\cite{Demirel:2011} \\  \cline{2-4}
                                & $ 1 |s_{ij}| \sum{w_{j}T_{j}}$  & Recozimento simulado, algoritmo genético, busca local e algoritmo genético com busca local & Feili~\cite{Feili:2011} \\  \cline{2-4}
                                & $ 1 |ST_{sd}| \sum{T_{j}}$  & Busca local \textit{multi-start} & Mendes et al.~\cite{Mendes:2002} \\ \cline{2-4}
                                & $ 1 |r_{j}, p_{j} = p, pmtn| \sum{T_{j}}$  & Técnica de decomposição & Tian et al.~\cite{Tian:2006} \\ \cline{2-4}
                                & $ 1 || \sum{w_{j}T_{j}}$  &  Método de busca \textit{dynasearch}  & Grosso et. al.~\cite{Grosso:2004} \\ \cline{2-4}
                                & $ 1 || \sum{w_{j}T_{j}}$  & Lista sequencial de busca local baseada em movimentos GPI, com critério de desempate  & Rodrigues et al.~\cite{RosianeArthurEduardoMarcus:2008} \\ \cline{2-4}
                                & $ 1 |r_{j}, p_{j} = p | \sum_{j}{T_{j}} $ & Programação Dinâmica  & Baptiste~\cite{Baptiste:2000} \\ \cline{2-4}
                                & $ 1 | r_{j} | \sum{w_{j}T_{j}}$  & Programação dinâmica  & Tanaka e Fujikuma~\cite{TanakaFujikuma:2011} \\ \hline
 \multirow{8}{*}{$\textbf{P}$}  & $ P || \frac{1}{n}\sum_{k = 1}^{m}{T(S_{k})}$ &  Busca tabu  & Armentano e Yamashita~\cite{Armentano:2000}  \\ \cline{2-4}
                                & $ P || \sum{w_{j}T_{j}}$  &  ILS com técnicas de busca em vizinhança de grande porte (VLNS)  & Croce et al.~\cite{DellaCroce2012}  \\ \cline{2-4}
                                & $ P || \sum{w_{j}T_{j}}$  & Lista sequencial de busca local baseada em movimentos GPI, com critério de desempate  & Rodrigues et al.~\cite{RosianeArthurEduardoMarcus:2008} \\ \cline{2-4}
                                & $ P || \sum{w_{j}T_{j}}$  & Algoritmo \textit{branch-cut-and-price}  & Pessoa et al.~\cite{ArturEduardoMarcusRosiane:2010} \\ \hline
 \multirow{5}{*}{$\textbf{Q}$}  & $ Q | p_{j} = 1 | \sum{T_{j}} $  & Algoritmo de troca de argumentos  &   Dessouky et al.~\cite{Dessouky:1990}  \\ \cline{2-4}
                                & $ Q | p_{j} = p, pmtn | \sum{T_{j}} $  & Algoritmo de tempo polinomial  & Kravchenko e Werner~\cite{kravchenko:2009}  \\ \cline{2-4}
                                & $ Q | p_{j} = 1 | \sum{w_{j}T_{j}} $  & Algoritmo de tempo polinomial  &   Dourado et al.~\cite{MitreRodriguesSzwarcfiter:2010}  \\ \hline
 \multirow{3}{*}{$\textbf{R}$}  & $ R_{m} | r_{j} | \sum_{j=1}^{n}{w_{j}T_{j}} = \sum_{j=1}^{n}{w_{j}(C_{j} - d_{j})^{+}}$, onde $MP$ é múltiplas máquinas & Heurística baseada em decomposição e busca em vizinhança variável (VNS)  & Bilyk e Mönch~\cite{Bilyk:2010} \\
\hline
\end{tabular}
\label{table:classificacao-WT}
% is used to refer this table in the text
\end{table}


\section{Escalonamento com antecipação de tarefas} \label{sec:E}

Em ambientes reais, os fabricantes não costumam estipular uma data de término sugerida para uma tarefa específica; ao invés disso, eles possuem datas pré-definidas ou previstas em que suas tarefas devem ser finalizadas, um exemplo seria as tarefas que devem ser entregues no final de cada dia de trabalho cuja antecipação é definida como a diferença entre o tempo de entrega e o tempo de completude ($C_j$) dessa tarefa \cite{Yang:2000}. A Figura~\ref{fig:earliness} mostra onde é possível obter o valor de antecipação de uma tarefa na linha do tempo. Observa-se que após a data de término sugerida $d_{j},$ o valor de antecipação é nulo mas, antes desta data de término sugerida, o valor de antecipação é monotonicamente decrescente. A Tabela~\ref{table:classificacao-WE} apresenta uma classificação dos problemas de escalonamento de tarefas com antecipação investigados nesta seção.

\begin{figure}[ht]
\centering
\includegraphics[width=.55\textwidth]{imagens/earliness}
\caption{Definição do valor de antecipação na linha do tempo.}
\label{fig:earliness}
\end{figure}

Cheng et al.~\cite{Cheng:1996} estudaram o problema de escalonamento em lotes (\textit{batches}), onde as tarefas em um lote são entregues ao cliente juntamente com o tempo de completude da última tarefa no lote, a antecipação dessa tarefa é definida como a diferença entre o tempo de entrega do lote, em que essa tarefa está inserida, e o seu tempo de completude. A abordagem utilizada foi a de programação dinâmica para o escalonamento de máquinas paralelas e uma abordagem semelhante foi considerada para o problema de escalonamento em lotes para o ambiente monoprocessado.

Gordon e Strusevich~\cite{Gordon:1999} consideraram o ambiente monoprocessado com datas de término sugeridas e problemas de escalonamento com $n$ tarefas em que as datas de término sugeridas são obtidas a partir de tempos de processamento com folgas $q$ (\textit{slack due dates}). Eles fazem uma consideração para as seguintes funções objetivo (importantes para o escalonamento e controle de aplicações): antecipação ponderada $\sum_{j=1}^{n} w_{j} E_{j}$, onde $w_{j}$ é um dado peso da tarefa $j$ que indica sua relativa importância e; antecipação com ponderações exponenciais $\sum_{j=1}^{n} w_{j} exp(\gamma E_{j})$, onde $\gamma \neq 0$.

Koksalan et al.~\cite{Koksalan:1998} consideraram o problema de escalonamento bicritério, considerando a minimização do tempo de fluxo e máxima antecipação de tarefas em ambiente monoprocessado, eles desenvolveram uma heurística para gerar sequências eficientes para o caso em que as máquinas podem possuir tempo ocioso e também fizeram considerações para casos sem tempo ocioso (um resumo sobre problemas de escalonamento que permitem ou não tempo ocioso é feito na seção~\ref{with-idle-without-idle-time}). 

Um caso de problemas de escalonamento com entrega em lotes e penalidades de antecipação foi estudado por Yang~\cite{Yang:2000}, onde foram considerados os problemas de escalonamento que minimizam dois tipos de penalidades de antecipação. No primeiro problema, o objetivo é achar uma sequência ótima tal que o tempo obtido no somatório das antecipações ponderadas seja mínimo. No segundo problema, o objetivo é achar uma sequência ótima tal que o valor obtido no somatório das antecipações ponderadas seja mínimo.

Pathumnakul e Egbelu~\cite{Pathumnakul-Egbelu:2005} propuseram uma heurística para minimizar a antecipação ponderada de tarefas sujeitas a uma data máxima de término (\textit{deadlines}) em ambiente monoprocessado, baseada em condições locais de otimalidade. A heurística começa escalonando cada tarefa de modo que o seu tempo de completude coincida com o seu \textit{deadline}. A solução obtida é conhecida como solução ideal. Se não houver conflito de execução entre as tarefas em uma máquina, isto é, se não houver sobreposição entre os tempos nos quais as tarefas deveriam estar sendo executadas, a solução obtida é ótima, senão a solução obtida é infactível. A heurística trabalha nestes conflitos até que não seja mais possível melhorar a solução. Os autores apresentam resultados para $10$, $15$, $20$, $25$ e $30$ tarefas, sendo que só foi obtido o ótimo para $10$ e $15$.

Um algoritmo \textit{branch-and-bound} foi proposto por Wu e Lee~\cite{WuLee:2006} para a minimização do tempo de preparação e da antecipação das tarefas em ambiente monoprocessado, onde o problema abordado consiste em várias tarefas que são agrupadas vários grupos (esses grupos representam um determinado pedido de um cliente). O tempo de preparação é utilizado somente quando uma tarefa muda de um grupo de tarefas para outro, o algoritmo \textit{branch-and-bound} foi capaz de prover uma solução ótima para instâncias de somente $12$, $15$ e $18$ tarefas. Outro algoritmo \textit{branch-and-bound} também foi proposto por Yin et al.~\cite{YinWuHsu:2012} juntamente com o algoritmo de Recozimento Simulado, que é utilizado para gerar uma solução inicial para o algoritmo, o algoritmo \textit{branch-and-bound} proposto é capaz de resolver instâncias do problema de até 28 tarefas.

Zhao e Tang~\cite{Zhao:2007} consideraram o problema de escalonamento em ambiente monoprocessado com efeitos tardios, eles propuseram soluções polinomiais para a minimização do problema de \textit{makespan} (momento em que termina a execução da última tarefa), o problema de minimização da soma dos tempos de completude e a soma de tarefas antecipadas ponderadas.


\begin{table}[htpb]
% title of Table
\centering
\caption{Classificação dos problemas de escalonamento com antecipação de tarefas.}
\scalefont{0.79}
% used for centering table
\begin{tabular}{c|p{4.5cm}|p{4.5cm}|p{2.5cm}}
\hline
 \multicolumn{1}{c|}{\textbf{Ambiente}} & \multicolumn{1}{c|}{\textbf{Problemas}} & \multicolumn{1}{c|}{\textbf{Estratégias de resolução}} &  \multicolumn{1}{c}{\textbf{Referências}} \\
\hline
 \multirow{9}{*}{$\textbf{1}$} &  $ 1 | prec, C_{j} \le d_{j} = p_{j} + q | \sum{w_j}E_{j} $, onde $q$ é a folga adicionada a data de término sugerida (\textit{slack due dates})  & Algoritmo de tempo polinomial com determinação de datas de término sugeridas  & Gordon e Strusevich~\cite{Gordon:1999}  \\ \cline{2-4}
                      &  $ 1 | C_{j} \le d_{j} = p_{j} + q | \sum{w_j}E_{j} $  & Algoritmo de tempo polinomial com determinação de datas de término sugeridas & Gordon e Strusevich~\cite{Gordon:1999}  \\ \cline{2-4}
                      &  $ 1 | D_{j} | \sum w_{j} E_{j} $  &  Algoritmo heurístico baseado em condições locais de otimalidade  & Pathumnakul e Egbelu~\cite{Pathumnakul-Egbelu:2005} \\ \cline{2-4}
                      &  $ 1 | s_{j} | \sum E_{j} $  &  Algoritmo \textit{branch-and-bound}  & Wu e Lee~\cite{WuLee:2006} \\ \cline{2-4}
                      &  $ 1 | | \sum w_{j} E_{j} $  &  Algoritmo \textit{branch-and-bound}  & Yin et al.~\cite{YinWuHsu:2012} \\
\hline
\end{tabular}
\label{table:classificacao-WE}
% is used to refer this table in the text
\end{table}


\section{Escalonamento com antecipação e atraso} \label{sec:ET}

Problemas de escalonamento com antecipação e atraso (Escalonamento E/T) representam situações importantes do mundo real, com o surgimento motivado pela adoção nas indústrias de processos produtivos com o conceito de produção sem folga (nem antes nem depois da data de término sugerida), ou seja, de produtos com produção concluída no momento em que devem ser entregues (do inglês, \textit{Just-in-Time} (JIT)). Tal termo surgiu no Japão na década de 70, na indústria automotiva, onde se buscava um sistema em que fosse possível coordenar uma determinada produção com a sua demanda específica e com o menor tempo de atraso possível. Esse sistema tem como objetivo a melhoria do processo produtivo e fluxo de manufatura, eliminação de estoques e desperdícios. A aplicação desse sistema é muito ampla, envolvendo a produção de produtos perecíveis por exemplo, mas abrangendo qualquer sistema em que as tarefas devam ser finalizadas o mais próximo possível do data de término estipulada~\cite{leung:2004}.

De acordo com Xiao e Li~\cite{Wen-qiang:2002}, decisões na determinação de datas de término sugeridas de tarefas são importantes no planejamento e controle de muitas operações de uma organização. Uma cotação rápida de entrega de um determinado trabalho pode ser muito atrativa para o cliente, mas pode aumentar a chance de entregas atrasadas. Por outro lado, a demora na cotação de um trabalho pode diminuir a chance de um trabalho ser entregue com atraso, mas será penalizado com o risco de se perder um determinado negócio em potencial.

A Figura~\ref{fig:earliness-tardiness} mostra onde é possível obter o valor de antecipação e atraso de uma tarefa na linha do tempo, onde o que se deseja é minimizar o valor de antecipação e atraso de modo que se tenha uma tarefa o mais próxima possível da data de término sugerida ($d_{j}$). Desta forma, quanto mais próxima a tarefa estiver da data de término estipulada, menor será o seu valor de antecipação e atraso. A Tabela~\ref{table:classificacao-WET} apresenta uma classificação dos problemas de escalonamento de tarefas com antecipação e atraso investigados nesta seção:

\begin{figure}[ht]
	\centering
	\includegraphics[width=.55\textwidth]{imagens/earliness-tardiness}
	\caption{Definição do valor de antecipação e atraso na linha do tempo.}
	\label{fig:earliness-tardiness}
\end{figure}

O conceito JIT também pode ser utilizado para gerir as atividades externas de uma empresa, como o processo de compra de insumos de outras fábricas, fabricação e montagem de novos produtos a partir desses insumos e distribuição ou exportação dos itens produzidos. JIT auxilia em todo esse processo, pois parte da ideia de 'conduzir' a produção a partir de uma determinada demanda, ou seja, a fábrica produz somente o necessário e nas quantidades necessárias quando requerido, evitando assim a quebra da cadeia de suprimentos da empresa e o acúmulo de itens produzidos no estoque, pois esses produtos são logos enviados ao mercado consumidor. A Figura~\ref{fig:JIT-example} apresenta uma aplicação do conceito JIT em uma empresa automotiva do polo industrial de Manaus.

\begin{figure}[ht]
\centering
\includegraphics[width=1.0\textwidth]{imagens/JIT-industria-HONDA.eps}
\caption{Aplicação do conceito JIT em uma empresa automotiva do Pólo Industrial de Manaus.}
\label{fig:JIT-example}
\end{figure}

Na literatura, os problemas de escalonamento que envolvem penalidades de antecipação e atraso são classificados em duas categorias principais, segundo os tipos de datas de término sugeridas, de acordo como abordado em Hassin e Shani~\cite{Hassin:2005}:

\begin{itemize}
   \item \textbf{Problemas de escalonamento com datas de término iguais (\textit{common due dates})}, $d_{j} = d$ - denotados como CDD, esse tipo de problemas são sub-divididos por aquele com \textbf{datas de término restritas} e com \textbf{datas de término irrestritas}. O problema de escalonamento é restrito, quando nenhuma tarefa pode inicializar seu processamento antes do instante zero. O problema de escalonamento é irrestrito, quando a data de término sugerida $d$ é suficientemente grande, por exemplo $d \ge \sum_{j=1}^{n} p_{j}$. Uma solução ótima para problemas de escalonamento com datas de término iguais devem satisfazer as seguintes propriedades (Baker e Scudder~\cite{baker:1990} e Hassin e Shani~\cite{Hassin:2005}):
   \begin{enumerate}
      \item não há tempo ocioso inserido (se a tarefa $j$ segue imediatamente a tarefa $i$ no escalonamento, $C_{j} = C_{i} + p_{j}$);
      \item a sequência deve possuir uma função de crescimento em \textbf{forma de V} (\textit{V-shaped}), ou seja, tarefas antecipadas ($C_{j} \le d$) são sequenciadas em ordem não-crescente e tarefas atrasadas ($C_{j} > d$) são sequenciadas em uma ordem não-decrescente, não permitindo tempo ocioso entre as tarefas;
      \item a $b-$ésima tarefa da sequência é concluída precisamente em sua data de término sugerida, onde $b$ é o menor valor inteiro que satisfaz a inequação $\sum_{j=1}^{b} \alpha_{j} \ge \sum_{i=b+1}^{n} \beta_{j}$ ($C_{j} = d$ para alguma tarefa $j$).
   \end{enumerate}
   Revisões da literatura e uma classificação dos problemas de escalonamento com penalidades de antecipação e atraso com datas de término iguais podem ser consultados em Baker e Scudder~\cite{baker:1990}, Hall et. al.~\cite{HallKubiakSethi:1991} e Gordon et al.~\cite{Gordon20021}.

   \item \textbf{Problemas de escalonamento com datas de término distintas (\textit{distinct due dates})}, $d_{j}$ - denotados como DDD e cujas três propriedades acima descritas, que definem uma solução ótima para problemas de escalonamento com datas de término iguais, não necessariamente podem ser utilizados para problemas de escalonamento com datas de término distintas. Baker e Scudder~\cite{baker:1990} afirmam que nenhuma das propriedades descritas para datas de término iguais podem ser aplicadas a problemas com datas de término distintas, pois \textbf{um escalonamento ótimo para datas de término distintas pode requerer tempo ocioso entre as tarefas}. Logo, a primeira propriedade é violada e a segunda também, uma vez que tais propriedades não permitem tempo ocioso ou a utilização de datas de término distintas. A terceira propriedade não se aplica, uma vez que múltiplas datas de término não podem ser acomodados de modo a terminarem todos na mesma data de término sugerida.

   Para resolver isso, James e Buchanan~\cite{James:1997} redefiniram tais propriedades para os problemas de escalonamento com datas de término distintas. Eles definiram um bloco como sendo um conjunto máximo de tarefas que são escalonados sem tempo ocioso, onde qualquer solução ótima para o problema satisfaz as três propriedades descritas acima com modificações simples, no que diz respeito a blocos de tarefas.
   Uma abordagem heurística híbrida para o problema, sem tempo ocioso, envolvendo algoritmo genético, busca local e recozimento simulado pode ser consultado em Rym e M'Hallah~\cite{Rym20073126}. Kanet e Sridharan~\cite{Kanet:2000} apresentaram uma revisão de problemas com tempos ociosos inseridos (IIT), onde é definida uma taxonomia dos problemas com IIT.
\end{itemize}

Existem casos especiais de problemas irrestritos com penalidades de antecipação e atraso unitários, ou seja, $\alpha = \beta = 1$, para $1 \le j \le n$, onde deseja-se minimizar $\sum_{j=1}^{n} (E_{j} + T_{j})$, dessa forma, o problema de escalonamento que envolve antecipação e atraso ponderados de tarefas é uma generalização desse problema, onde $\alpha_{j} = \alpha$ e $\beta_{j} = \beta$ para $1 \le j \le n$ e deseja-se minimizar $\sum_{j=1}^{n} (\alpha_{j} E_{j} + \beta_{j} T_{j})$. Verma e Dessouky~\cite{VermaDessouky:1998} consideraram o problema em ambiente monoprocessado considerando tempos de processamento unitários e casos de pesos de antecipação e atraso unitários, onde $\alpha_{i} = \beta_{i} = 1$ $\forall i \in n$, pesos de antecipação e atraso idênticos, onde a taxa $\alpha_{i}/\beta_{i}$ ou a diferença $\alpha_{i} - \beta_{i}$ é o mesmo para todas as tarefas, penalidades idênticas de antecipação, $\alpha_{i} = \alpha$ $\forall i \in n$ e penalidades idênticas de atraso, $\beta_{i} = \beta$ $\forall i \in n$.
Shabtay e Steiner~\cite{ShabtaySteiner:2012} apresentam uma revisão da literatura sobre problemas de escalonamento JIT, onde é apresentado o problema de maximização do número ponderado de tarefas que são finalizadas exatamente em suas datas de término sugeridas e também são apresentados vários ambientes de escalonamento com tempos de processamento fixos e variáveis.

Nas próximas sub-seções serão apresentadas as principais abordagens da literatura sobre problemas de escalonamento de tarefas com penalidades de antecipação e atraso, com tempo ocioso e não-ocioso, juntamente com trabalhos relacionados que envolvem ambientes monoprocessados e máquinas paralelas idênticas, uniformes e não-relacionadas.


\subsection{Tempo ocioso $\times$ não-ocioso} \label{with-idle-without-idle-time}

Como visto na seção anterior, um escalonamento com datas de término iguais não possuem tempo ocioso em um escalonamento ótimo, antes que a última tarefa do escalonamento seja completada. Entretanto, no caso das tarefas com datas de término distintas, pode ser vantajoso segurar a produção por algum tempo a fim de reduzir os custos decorrentes a antecipação de tarefas, assim, é possível que se tenha tempo ocioso no escalonamento. Esta seção baseia-se na seguinte referência: Józefowska~\cite{jozefowska2007just}.

A Figura~\ref{fig:sched-with-idle-noidle} apresenta dois exemplos de escalonamento, sem tempo ocioso (Figura~\ref{fig:sched-with-idle-noidle} (a)) e com tempo ocioso (Figura~\ref{fig:sched-with-idle-noidle} (b)), considerando duas tarefas com tempo de processamento igual a $6$, datas de término sugeridas $d_{1} = 8$ e $d_{2} = 17$, em ambiente monoprocessado. Se o tempo ocioso não é permitido (Figura~\ref{fig:sched-with-idle-noidle} (a)), a primeira tarefa inicia o seu processamento no instante $0$, e possui um tempo de completude $C_{1} = 6$. Dessa forma, a segunda tarefa inicia no instante $6$ e finaliza seu processamento no instante $12$, $C_{2} = 12$. No escalonamento da Figura~\ref{fig:sched-with-idle-noidle} (a) as tarefas são completadas antes da data de término sugerida, o valor de antecipação associado a cada tarefa é obtido desde que $d_{1} - C_{1} = 2 > 0$ e $d_{2} - C_{2} = 5 > 0$. No escalonamento da Figura~\ref{fig:sched-with-idle-noidle} (b) dois períodos de tempo ocioso ocorrem, como resultado, as tarefas são completadas exatamente em suas datas de término sugeridas. Assim, os custos de antecipação e atraso são nulos.

\begin{figure}[ht]
\centering
\includegraphics[width=0.55\textwidth]{imagens/sched-with-idle-noidle.eps}
\caption{Escalonamento com tempo ocioso $\times$ não-ocioso~\cite{jozefowska2007just}.}
\label{fig:sched-with-idle-noidle}
\end{figure}

A inserção de tempo ocioso no escalonamento resulta em uma subutilização da máquina. A maximização na utilização da máquina geralmente entra em conflito com o valor de função objetivo JIT, o que pode impactar diretamente nos custos de estoque de uma empresa. Apesar do custo decorrente da existência de tempo ocioso na máquina não ser desprezível, ele é compatível com o conceito JIT quando se quer obter o menor valor de antecipação e atraso possível. Mas se o custo do tempo ocioso na máquina for elevado, pode ser necessária a aplicação de uma restrição adicional a fim de evitar tempo ocioso no escalonamento. Assim, tem-se dois grupos principais de problemas de escalonamento: problemas com tempo ocioso permitido e problemas sem tempo ocioso. O primeiro caso é mais consistente com a ideia do escalonamento JIT, enquanto que a versão sem tempo ocioso pode ter seu uso justificado em outras aplicações.

Dependendo do problema de antecipação e atraso considerado, tem problemas de escalonamento que não permitem tempo ocioso entre as tarefas devido as restrições do problema, como as linhas de produção de uma fábrica, por exemplo, que não podem parar e devem seguir um fluxo contínuo de produção. Outro exemplo é quando se tem máquinas muito caras, que precisam ser utilizadas em uma determinada aplicação, logo, a sua utilização deve ser maximizada. Dessa forma, a restrição que evita tempo ocioso, apesar de não ser muito compatível com o conceito JIT, é também considerada na literatura. 

Por outro lado, há problemas que permitem tempo ocioso no escalonamento, também devido as restrições do problema, ou seja, existem problemas que requerem que as tarefas terminem o mais próximas da data de término possível, a fim de atender a um determinado cronograma de produção ou atender as necessidades de um cliente, por exemplo. Dessa forma, com um número razoável de tarefas terminando na data de término sugerida, os custos das penalidades de antecipação e atraso tendem a ser reduzidos. Assim, pode ser mais lucrativo considerar tempo ocioso em alguns problemas.

Os problemas de escalonamento com e sem tempo ocioso podem ser encontrados na literatura com as seguintes variações de datas de término sugeridas:

\begin{itemize}
  \item Escalonamento com tempo ocioso:
  \begin{itemize}
	  \item[a)] Pesos arbitrários (\textit{arbitrary weights}): $\alpha \neq \beta$.
	  \item[b)] Pesos proporcionais (\textit{proportional weights}): $\alpha_{i} = \alpha p_{i}$ e $\beta_{i} = \beta p_{i}$, $i = 1,...,n$, $\alpha, \beta \ge 0$.
  \end{itemize}
  
  \item Escalonamento sem tempo ocioso:
    \begin{itemize}
  	  \item[a)] Pesos arbitrários (\textit{arbitrary weights}): $\alpha \neq \beta$.
  	  \item[b)] Pesos independentes de tarefa (\textit{job independent weights}): $\alpha_{i} = \alpha$ e $\beta_{i} = \beta$, $i = 1,...,n$.
    \end{itemize}
\end{itemize}


\subsection{Ambiente monoprocessado com antecipação $\&$ atraso}

O problema de Escalonamento E/T em máquina única consiste em encontrar uma sequência ótima de um conjunto de $n$ tarefas a serem
escalonadas em uma única máquina. Cada tarefa $J_j$ possui um tempo de processamento inteiro $p_j$ e uma data de término sugerida inteira $d_j$. Caso as tarefas estejam prontas para serem executadas a partir do instante zero e não houver preempção das tarefas,
não é permitido tempo ocioso porque a capacidade da máquina é limitada, comparada a demanda, e não é tecnologicamente viável deixar a máquina parada por um longo tempo \cite{Rym20073126}.

Herrmann e Lee~\cite{Herrmann:1993} resolveram o problema de escalonamento para minimizar a soma das penalidades de antecipação e atraso e os custos de entrega, onde as tarefas atrasadas são concluídas em lotes, com um custo fixo por lote, como no problema: min $\sum{(\alpha_{j}E_{j} + \beta_{j}T_{j} + Ky_{j})}$, onde $\alpha_{j}$ é a taxa de penalidade de antecipação, $\beta_{j}$ é a taxa de penalidade de atraso, $K$ é o custo da entrega do lote, $d$ é uma dada data de término igual, $D_{j}$ é a data de entrega da tarefa (onde $D_{j} \ge C_{j}$ e $D_{j} = d$ se $C_{j} \le d$) e $y_{j}$ = 1 se $D_{j} = C_{j} > d$ e $0$ caso contrário. A estratégia algorítmica utilizada para o problema é um algoritmo pseudopolinomial de programação dinâmica.

Sourd e Kedad-Sidhoum~\cite{SourdandKedad-Sidhoum:2003} lidaram com problemas envolvendo datas de término sugeridas, custos de antecipação e custos de atraso distintos e, com o objetivo de determinar o custo mínimo do problema, eles propuseram novos limites inferiores através da decomposição de cada tarefa em operadores unários, que por sua vez são atribuídos a cada instante de tempo, o que fornece um escalonamento preemptivo. Assim, dependendo de onde esses operadores unários são atribuídos na janela de tempo, gera uma custo associado no escalonamento, a atribuição que gerar o menor custo para o escalonamento é assumido como o limite inferior válido. 

Um algoritmo \textit{branch-and-bound} é proposto baseado neste limite inferior, obtendo resultados rápidos para instâncias envolvendo $8$, $10$, $15$, $20$, $25$ e $30$ tarefas. Em outro trabalho, os autores Sourd e Kedad-Sidhoum~\cite{Sourd:2008} apresentam um novo algoritmo \textit{branch-and-bound} capraz de resolver instâncias com até $50$ tarefas, o algoritmo é baseado na combinação da relaxação lagrangeana de restrição de recursos e novas regras de dominância.

Uma meta-heurística híbrida foi proposta por M'Hallah~\cite{Rym20073126} para o problema $1 | d_{j}| \sum{E_{j}} + \sum{T_{j}}$. Essa heurística é baseada em população, envolvendo Algoritmo Genético e a exploração do espaço de busca envolve Busca Local e Recozimento Simulado. A heurística baseada em população objetiva uma otimização global enquanto que a heurística de busca local se esforça para a otimização de um ótimo local, a otimização global equipara-se a evolução, enquanto que a otimização local equipara-se à aprendizagem. O autor afirma que a sincronização da evolução com aprendizagem gera uma heurística híbrida eficiente. O problema $1 | d_{j} | \sum{E_{j}} + \sum{T_{j}}$ é NP-difícil, sendo uma generalização de $1 | d_{j} | \sum{T_{j}}$ que também é NP-difícil. O algoritmo proposto possui dois níveis de hibridização, que são: baixo nível (onde é verificada a habilidade do Algoritmo Genético, de atingir boas soluções, substituindo a operação genética de mutação pela busca local) e o alto nível (onde são utilizadas três heurísticas gulosas para gerar uma população inicial, e a população é refinada a cada geração pelo algoritmo de Recozimento Simulado). A abordagem além de gerar resultados promissores em um tempo razoável, atingindo o ótimo na maioria dos casos testados, também pode ser estendido para outros problemas que envolvem antecipação e atraso.

Shabtay e Steiner~\cite{ShabtaySteiner:2008} apresentam um estudo envolvendo os dois tipos de abordagem para datas de término sugeridas citadas anteriormente: datas de término iguais (\textit{common due dates}) e datas de término irrestritas (\textit{unrestricted due dates}). Com base nestes dois, trabalharam também com a ideia de \textbf{datas de término com folga} (\textit{slack due dates}), geralmente referenciado como SLK, onde as datas de término de todas as tarefas recebem folgas ($slk$), o que reflete a um mesmo tempo de espera para todas as tarefas, ou seja, $d_{j} = p_{j} + slk$ para $j=1,...,n$, onde $slk \ge 0$ é uma variável de decisão.

Kedad-Sidhoum et al.~\cite{Kedad-Sidhoum:2008} propuseram duas novas famílias de limites inferiores para o problema de escalonamento em que as tarefas possuem datas de término distintas com custos de antecipação e atraso. Primeiro foi feita uma generalização de duas atribuições de limites inferiores para o problema com máquinas monoprocessadas e máquinas paralelas, e segundo, foi investigado uma formulação indexada por tempo para o problema a fim de se obter eficientes limites inferiores através da geração de colunas e relaxação lagrangeana. Para a geração de limite superior, foi apresentado um algoritmo de busca local.

Um algoritmo \textit{branch-and-bound} para o problema de escalonamento com penalidades de antecipação e atraso pode ser consultado em Tanaka et al.~\cite{1244636}, onde o procedimento começa com uma solução inicial é obtida através do algoritmo de troca de pares adjacentes (\textit{adjacent pairwise interchange} - API), Figura~\ref{fig:pairwise}, esse algoritmo sequencia a solução inicial ordenando as tarefas a partir do menor para a maior data de término sugerida seguido de movimentos API até que a solução não possa mais ser melhorada.

Tanaka et al.~\cite{Tanaka:2009:EAS:1644424.1644462} também consideraram um algoritmo de programação dinâmica para solucionar os problema de escalonamento com antecipação e atraso ponderados de tarefas, apresentando resultados para até $300$ tarefas. Uma outra versão desse algoritmo é apresentada em Tanaka et al.~\cite{Tanaka:2012}, onde o algoritmo começa o seu processamento através da relaxação lagrangeana do problema original e, então, restrições são adicionadas até que a diferença entre o limite inferior e superior se torne zero. As relaxações são resolvidas pela programação dinâmica, e os estados desnecessários do algoritmo de programação dinâmica são eliminados no decorrer da execução do algoritmo, a fim de evitar o crescimento excessivo de estados causados pela adição de restrições.

\begin{figure}[ht]
\centering
\includegraphics[width=.4\textwidth]{imagens/pairwise.eps}
\caption{Exemplo do método de troca de pares adjacentes para as tarefas $j$ e $k$. Adaptado de Pinedo~\cite{pinedo:2012}.}
\label{fig:pairwise}
\end{figure}

Diferentes estratégias aproximadas envolvendo o ambiente monoprocessado pode ser consultado em Sourd~\cite{Sourd2006591}, que considerou o método de busca em vizinhança chamado de \textit{dynasearch} ou busca em vizinhança muito grande, onde a vizinhança é obtida através da composição de várias operações de troca de posições do escalonamento e, como a vizinhança é exponencial, um algoritmo de programação dinâmica foi proposto a fim de se obter a solução ótima da vizinhança. Júnior e Carvalho~\cite{JuniorCarvalho:2007}, considerando janelas de entrega e tempo de preparação da máquina dependente da sequência de produção, propuseram um método heurístico baseado em GRASP, busca local iterada e descida em vizinhança variável (\textit{variable neighborhood descent}), onde a heurística possui dois passos: o primeiro é a determinação da sequência de tarefas e o segundo passo é a determinação da data ótima de início processamento de cada tarefa na sequência.

Penna et al.~\cite{Penna:2012} consideraram o escalonamento de tarefas com penalidades de antecipação e atraso com janelas de entrega distintas (onde há um período para a conclusão de cada tarefa), onde utilizou-se um algoritmo heurístico baseado em três fases, a primeira delas diz respeito ao algoritmo GRASP para a geração de uma solução inicial viável, a segunda fase é baseada em busca tabu a fim de se seja refinada a solução encontrada e a terceira fase conta com o algoritmo de reconexão de caminhos como estratégia de pós-otimização. O algoritmo foi testado com até $75$ tarefas e foi comparado com algoritmos da literatura, superando todos eles. Um algoritmo genético em ambiente monoprocessado foi proposto por Yousefi et al.~\cite{Yousefi2012}, onde foi considerado um estudo de caso de uma aplicação do algoritmo na indústria, onde são consideradas tarefas que possuem datas de término iguais, e o algoritmo é aplicado para o escalonamento de produtos em uma linha de produção.


\subsection{Máquinas paralelas com antecipação $\&$ atraso}

Os problemas de escalonamento que envolvem restrições de antecipação e atraso consistem em achar a sequência ótima para um dado conjunto de $n$ tarefas $N = \{ J_{1}, J_{2}, ..., J_{n} \}$ com tempos de processamento $p_{j}(j = 1, 2, ..., n)$ a serem processadas em: \textbf{máquinas paralelas idênticas} $P$ (cada máquina possui a mesma velocidade, e tempo de processamento para a tarefa $j$ é $p_{j}$); \textbf{máquinas paralelas uniformes} $Q$ (cada máquina $i$ possui a sua própria velocidade $s_{i}$, e o tempo de processamento da tarefa $j$ nessa máquina será $p_{ij} = p_{j}/s_{i}$) ou \textbf{máquinas paralelas não-relacionadas} $R$ (a velocidade da máquina é dependente da tarefa a ser executada, e o tempo de processamento da tarefa $j$ na máquina $i$ é $p_{ij} = p_{j}/s_{ij}$). Os casos de \textit{job shop} (máquinas diferentes e em ordem diferente para cada tarefa), \textit{flow shop} (onde se tem uma sequência de máquinas para cada tarefa) e \textit{open shop} (onde cada máquina opera exatamente uma vez em cada sequência, diferentes para cada tarefa) também são detalhados na literatura \cite{Lauff2004637}. Kravchenko e Werner~\cite{Kravchenko:2011} apresentam uma revisão da literatura envolvendo problemas de escalonamento em máquinas paralelas. 


\subsubsection{Máquinas paralelas idênticas}

Nesta subseção, são apresentados os principais trabalhos encontrados na literatura envolvendo ambientes de máquinas paralelas idênticas ($P$). Ressalta-se que os trabalhos encontrados que envolvem máquinas paralelas uniformes e não-relacionadas também se adequam, a menos de algumas adaptações necessários em alguns casos, ao caso de ambiente em máquinas paralelas idênticas. Ainda assim, não foram encontrados muitos trabalhos para este caso específico somente, e os dois principais encontrados são apresentados a seguir.

Kedad-Sidhoum et al.~\cite{Kedad-Sidhoum:2008}, resolvem o problema $ P |r_{j}| \sum_{j}{\alpha_{j}E_{j} + \beta_{j}T_{j}}$ utilizando programação inteira, através de uma estratégia algorítmica combinando geração de colunas, relaxação lagrangeana e heurística de busca local.

Xiao e Li~\cite{Wen-qiang:2002} propuseram duas heurísticas para minimizar o problema $nP_{D}d + \sum_{j=1}^{n}{(P_{E}E_{j} + P_{T}T_{j})}$, onde as penalidades que são aplicadas às tarefas são: $P_E$ que representa as penalidades de antecipação, $P_{T}$ que representa as penalidades de atraso e $nP_{D}d$ que é aplicado quando há datas de término iguais. A primeira heurística desenvolvida minimiza a somatória ponderada das datas de término sugeridas, tempo total de antecipação e tempo total de atraso. A segunda heurística desenvolvida possui a melhor performance no pior caso para o caso de penalidades de antecipação antecipadas, ou seja, corresponde a situação onde ocorre o custo de armazenamento por causa das tarefas finalizadas antes da data de término sugerida, que é desprezível se for comparado com as datas de término sugeridas e penalidades sobre tarefas atrasadas.


\subsubsection{Máquinas paralelas uniformes}

Nesta subseção, são apresentados os principais trabalhos encontrados na literatura envolvendo ambientes de máquinas paralelas uniformes ($Q$).

Tuong e Soukhal~\cite{Tuong:2008} consideraram problemas de escalonamento com $n$ tarefas com tempos iguais de processamento que devem ser escalonados em $m$ máquinas uniformes, onde $l$ é uma dada data de término sugerida $(l < n)$, foi mostrado que o problema de escalonamento em $m$ máquinas uniformes é solucionável em tempo polinomial.

Soukhal e Toung~\cite{Soukhal:2012} estudaram problemas com datas de término iguais de antecipação e atraso em ambiente monoprocessado e máquinas paralelas em que o tempo de processamento das tarefas são idênticos, onde dois casos de datas de término sugeridas foram considerados. No primeiro caso, é o caso em que a data de término sugerida é suficientemente adiantada (versão restritiva) ou não (versão não-restritiva) para restrição de solução ótima, o segundo caso lida com datas de término desconhecidas que são as variáveis de decisão. É feita uma demonstração que o problema $Q_{m} | p_{j} = p$, $d_{j} = d$, não restritivo $|\sum(\alpha E_{i} + \beta T_{i})$ pode ser executado em tempo polinomial, $O(m^{2})$, com penalidades unitárias para antecipação e atraso.


\subsubsection{Máquinas paralelas não-relacionadas}

Nesta subseção, são apresentados os principais trabalhos encontrados na literatura envolvendo ambientes de máquinas paralelas não-relacionadas ($R$).

Sung e Vlach~\cite{Sung:2005} consideraram os problemas de escalonamento não-preemptivos com o objetivo de maximizar o número ponderado de tarefas que são completadas exatamente em duas datas de término sugeridas. Foi apresentado um algoritmo de programação dinâmica de tempo polinomial quando o número de máquinas é fixo e posteriormente é mostrado que se o número de máquinas faz parte da entrada, o problema se torna NP-Difícil.

Beyranvand et al.~\cite{Beyranvand:2011} lidaram com este problema com datas de término restritivas, na literatura, este problema é denotado por $R | d_{i} = d^{r} | \sum_{i}{\alpha_{i}E_{i} + \beta_{i}T_{i}} $, onde $\alpha_{i}$ e $\beta_{i}$ são as penalidades de antecipação e o atraso, respectivamente, $E_{i}$ e $T_{i}$ são os valores de antecipação e atraso, respectivamente, $d^{r}$ é a data de término restritiva, isso significa que todas as tarefas devem idealmente serem concluídos, ou seja, existe pelo menos uma máquina $m$ com $\sum_{j}{p_{ij} > d^{r}}$. Para solucionar esse problema de escalonamento, foi proposto o modelo de programação quadrática com restrições lineares com o objetivos de se obter soluções ótimas para o problema.

Vallada e Ruiz~\cite{Vallada:2012} consideraram o problema de escalonamento em máquinas não-relacionadas, eles estudaram formulações matemáticas existentes, como o modelo de programação inteira mista (PIM) e um algoritmo genético foi proposto para o problema $R | S_{ijk} | \sum_{j=1}^{n}{(w^{'}_{j}E_{j} + w_{j}T_{j})}$. No problema estudado, $w^{'}_{j}$ é o peso da antecipação ou prioridade e $w_{j}$ é o peso do atraso ou prioridade, não necessariamente igual a $w^{'}_{j}$. O tempo de preparação (\textit{setup}) $S_{ijk}$ é fixo e não-negativo, sendo o tempo necessário para a máquina $i$, $ \forall i \in M $, processar a tarefa $j$ quando a tarefa $k$ for a próxima da sequência, $\forall j$, $k$, $j \neq k$, $\in N$.

Estratégias aproximadas podem ser consultadas em Nogueira et al.~\cite{Nogueira:2012}, onde foi proposta uma heurística híbrida baseada na meta-heurística GRASP e reconexão de caminhos, de maneira que, para cada solução gerada pela heurística é utilizado um algoritmo de tempo polinomial para determinar a data ótima de início das tarefas, são apresentados resultados para $8$, $9$, $10$, $20$ e $30$ tarefas.


\begin{table}[htpb]
% title of Table
\centering
\caption{Classificação dos problemas de escalonamento com antecipação e atraso de tarefas.}
\scalefont{0.78}
% used for centering table
\begin{tabular}{c|p{4.5cm}|p{5cm}|p{2.2cm}}
\hline
 \multicolumn{1}{c|}{\textbf{Ambiente}} & \multicolumn{1}{c|}{\textbf{Problemas}} & \multicolumn{1}{c|}{\textbf{Estratégias de resolução}} &  \multicolumn{1}{c}{\textbf{Referências}} \\
\hline
 \multirow{32}{*}{$\textbf{1}$} &  $ 1 |s-batch, d_{j} = d| \sum{(\alpha_{j}E_{j} + \beta_{j}T_{j} + Ky_{j})}$, $Ky_{j}$ é o custo da entrega do lote & Programação dinâmica & Herrmann e Lee \cite{Herrmann:1993} \\ \cline{2-4}
                                &  $ 1 | | \sum{\alpha_{i}E_{i}} + \sum{\beta_{i}T_{i}}$ & Programação dinâmica & Tanaka et al. \cite{Tanaka:2009:EAS:1644424.1644462}, Tanaka et al. \cite{Tanaka:2012} \\ \cline{2-4}
 		                        &  $ 1 |ST_{sd}| \sum{w_{j}E_{j}} + \sum{w_{j}T_{j}}$ & Busca tabu & Kolahan e Liang \cite{KolahanLiang:1998} \\ \cline{2-4}
 		                        &  $ 1 |ST_{sd}| \sum{w_{j}E_{j}} + \sum{w_{j}T_{j}}$ & Método de busca \textit{Dynasearch} & Sourd \cite{Sourd2006591} \\ \cline{2-4}
 		                        &  $ 1 | | \sum{\alpha_{j}E_{j}} + \sum{\beta_{j}T_{j}}$ & Algoritmo \textit{branch-and-bound} & Sourd e Kedad-Sidhoum \cite{SourdandKedad-Sidhoum:2003}, \cite{Sourd:2009:NEA:1535803.1535816} \\  \cline{2-4}
 		                        &  $ 1 | r_{j} | \sum{\alpha_{j}E_{j}} + \sum{\beta_{j}T_{j}}$ & Algoritmo \textit{branch-and-bound} & Sourd e Kedad-Sidhoum \cite{Sourd:2008} \\  \cline{2-4}
                                &  $ 1 |ST_{sd}| \sum{E_{j}} + \sum{T_{j}}$ & Algoritmo \textit{branch-and-bound} & Rabadi \cite{Rabadi:2004} \\  \cline{2-4}
                                &  $ 1 | d_{j}| \sum{E_{j}} + \sum{T_{j}}$ & Algoritmo genético híbrido envolvendo busca local e recozimento simulado & M'Hallah \cite{Rym20073126} \\ \cline{2-4}
                                & $ 1 | ST_{sd}, s_{ij} | \sum_{j=1}^{n}{(\alpha_{i}T_{j} + \beta_{j}E_{j})}$ &  GRASP, busca local iterada e descida em vizinhança variável & Carvalho \cite{JuniorCarvalho:2007} \\ \cline{2-4}
 		                        &  $ 1 | d_{i} | \sum{w_{i}E_{i}} + \sum{h_{i}T_{i}}$ & Algoritmo \textit{branch-and-bound} & Li~\cite{GeorgeLi:1996}, Rebai e Kacem \cite{Rebai:2008} \\ \cline{2-4}
 		                        &  $ 1 | | \sum{\alpha_{i}E_{i}} + \sum{\beta_{i}T_{i}}$ & Algoritmo \textit{branch-and-bound} & Tanaka et al. \cite{1244636} \\ \cline{2-4}
 		                        &  $ 1 | ST_{sd}, E_{i} \le d_{i} \le T_{i} | \sum_{i=1}^{n}{(\alpha_{i}E_{i} + \beta_{i}T_{i})}$, onde $E_{i} \le d_{i} \le T_{i}$ indica a janelas de entrega distintas & GRASP, busca tabu e reconexão de caminhos & Penna et al. \cite{Penna:2012} \\ \cline{2-4}
 		                        &  $ 1 | d_{j} = d | \sum_{i=1}^{n}{(\alpha_{i}E_{i} + \beta_{i}T_{i})}$ & Algoritmo genético &  Yousefi et al. \cite{Yousefi2012} \\ \hline
 \multirow{6}{*}{$\textbf{P}$}  & $ P || nP_{D}d + \sum_{j=1}^{n}{(P_{E}E_{j} + P_{T}T_{j})}$, $nP_{D}d$ é uma penalidade aplicada quando há datas de término iguais & Abordagem heurística baseada em formulação matemática & Xiao e Li \cite{Wen-qiang:2002}  \\ \cline{2-4}
                                & $ P |r_{j}| \sum_{j}{\alpha_{j}E_{j} + \beta_{j}T_{j}}$ & Programação inteira, geração de colunas, relaxação lagrangeana e busca local  & Kedad-Sidhoum et al. \cite{Kedad-Sidhoum:2008}  \\ \hline
 \multirow{4}{*}{$\textbf{Q}$}  & $ Q_{m} |p_{i} = p, d_{i} \in D, |D| \le l, l$ fixo $|\sum(\alpha_{i}E_{i} + \beta_{i}T_{i})$  &  Prova matemática que o problema é solucionável em tempo polinomial  &  Tuong e Soukhal \cite{Tuong:2008}   \\ \cline{2-4}
                                & $ Q_{m} | p_{j} = p$, $d_{j} = d$, não-restritivo $|\sum(\alpha E_{i} + \beta T_{i})$ & Prova matemática que o problema é solucionável em tempo polinomial & Soukhal e Toung \cite{Soukhal:2012}  \\ \hline
 \multirow{5}{*}{$\textbf{R}$}  & $ R_{m} |  | w_{j}(\sum{E_{j}} + \sum{T_{j}}) $  & Programação dinâmica & Sung e Vlach \cite{Sung:2005}   \\ \cline{2-4}
                                & $ R | s_{ijk} | \sum_{j=1}^{n}{(w^{'}_{j}E_{j} + w_{j}T_{j})}$ & Algoritmo genético & Vallada e Ruiz \cite{Vallada:2012} \\ \cline{2-4}
                                & $ R | s_{ijk} | \sum_{j=1}^{n}{(\alpha_{i}T_{j} + \beta_{j}E_{j})}$ & GRASP com reconexão de caminhos & Nogueira et al.~\cite{Nogueira:2012} \\
\hline
\end{tabular}
\label{table:classificacao-WET}
\end{table}


\section{Critério de desempate} \label{Section:CDVAL}

Durante o processo de busca por melhores soluções, há grande possibilidade que se encontre muitas soluções diferentes mas de mesmo custo em relação à função objetivo que penaliza tarefas ponderadas com antecipação ou atraso. Assim, faz-se necessário a escolha de um critério sobre o qual uma solução deve ser escolhida ou priorizada uma solução em relação a outra de igual valor de função objetivo. Rodrigues et al. \cite{RosianeArthurEduardoMarcus:2008} propuseram uma estratégia de \textbf{Critério de Desempate} (CD) para o problema de escalonamento com função objetivo que penaliza o atraso de tarefas ponderadas e que permite escolher, entre duas soluções com o mesmo valor de função objetivo, qual solução deve ser considerada a melhor solução. O critério de desempate proposto se baseia em datas de término sugeridas (\emph{due dates}) das tarefas escalonadas e na posição das mesmas na sequência do escalonamento (solução), priorizando aqueles escalonamentos que possuem tarefas com datas de término menores escalonadas primeiro no escalonamento. Tal critério de desempate foi motivado pela política de escalonamento bem conhecida que consiste em escalonar primeiro as tarefas de datas de término menores (\emph{earliest due date first rule}), o que é uma regra ótima - gera a solução ótima - para o problema $1|| \sum w_jT_j$ quando não existirem tarefas tardias (quando o valor da função objetivo for zero).

Formalmente, dado um escalonamento representado por uma sequência de tarefas $\pi = (\pi_{1}, ..., \pi_{n})$, define-se $b(\pi)$ como uma pontuação da permutação $\pi$, que será dada por:

\begin{equation}
  b(\pi) = \sum_{j=1}^{n}{d_{\pi_{j}} \cdot (n - j + 1)}.
\end{equation}

\noindent Assim, dada duas sequências  $\pi$ e $\rho$ de tarefas com o mesmo custo de função objetivo, se $b(\rho) < b(\pi)$, então $\rho$ é considerada melhor solução que $\pi$.

Neste trabalho, o problema de escalonamento principal abordado envolve não somente a penalização de atraso, mas simultaneamente, a penalização de antecipação e de atraso de tarefas ponderadas. Ainda assim, como a região de soluções viáveis para o problema permanece a mesma e a nova função objetivo é uma composição envolvendo a função anterior, pode ser observado através de uma análise simples e posteriormente comprovados por análise empírica, que empates entre soluções continuam ocorrendo em grande número considerando esta nova função objetivo.

Sendo assim, tal critério de desempate foi aplicado no processo de busca local proposto neste trabalho, onde frequentemente soluções vizinhas no espaço de busca possuem custos iguais apesar de serem soluções diferentes e, então, o processo de busca local pode ser interrompido prematuramente, sem realmente devolver um ótimo local que expressa uma solução de melhor qualidade. Assim, como será apresentado posteriormente, tal critério de desempate foi adotado na heurística de busca local implementada, bem como alguns resultados da análise de ocorrência de empates segundo este critério são apresentados.

Uma questão interessante não explorada neste trabalho, seria adequar uma política de escalonamento mais adequada para tal função composta, de tal forma a favorecer casos em que ocorra um índice de antecipação muito grande. Isto não está sendo tratado neste trabalho e apenas o atraso está sendo priorizado como critério de desempate. Outra estratégia interessante a ser explorada seria a determinação de soluções simétricas no espaço de busca, o que pode representar um considerável ganho de desempenho na execução de estratégias exatas e aproximadas, a seção seguinte apresenta um estudo inicial sobre simetria em escalonamento de tarefas.


\section{Identificando simetria} \label{Simetria}

Além de existirem muitas soluções diferentes com mesmo valor de função objetivo, é possível a existência de simetria no escalonamento, ou seja, soluções que a princípio são diferentes, envolvendo tarefas alocadas em diferentes máquinas e posições no tempo, mas que na verdade são similares em relação a estrutura geral do problema, de tal forma que bastaria considerar uma delas em um processo algorítmico de geração de soluções. Em suma, a identificação e remoção de tais soluções simétricas pode reduzir consideravelmente o esforço computacional de uma determinada estratégia algorítmica, evitando o esforço repetitivo do método em recalcular soluções equivalentes desnecessárias no processo de busca.

Neste trabalho, o estudo da ocorrência de simetria nos problemas de escalonamento em análise, propiciou a detecção de \textbf{blocos de tarefas simétricos} no escalonamento considerando máquinas paralelas idênticas. Dado um escalonamento, considera-se aqui que um \textbf{bloco de tarefas} consiste em uma janela de tempo no escalonamento cujas tarefas contidas são completamente executadas neste intervalo (começam e terminam suas execuções nesta janela de tempo). Sendo assim, um bloco de tarefas em um escalonamento é simétrico a outro bloco, de outro escalonamento, se contém as mesmas tarefas escalonadas, mesmo estando em máquinas e ordem diferentes. Conceitualmente, em tais blocos simétricos pode existir tempo ocioso entre as tarefas escalonadas ou não.

Detectar blocos simétricos é uma outra forma de refinar o processo de obtenção de soluções, podendo melhorar o desempenho dos algoritmos relacionados. Uma solução (um mesmo escalonamento de tarefas) pode possuir um ou vários blocos simétricos. A Figura~\ref{fig:Sym-CDVAL} apresenta um exemplo de blocos simétricos no escalonamento, onde pode-se observar duas soluções diferentes para o problema, mas que possuem o mesmo custo e valores diferentes dados pelo critério de desempate.  A Figura~\ref{fig:Sym-CDVAL} (a) apresenta um exemplo de instância de $8$ tarefas para o problema de escalonamento com penalidades de antecipação e atraso. Baseado nesta instância, são apresentadas duas soluções ótimas para o problema: a primeira delas contém dois blocos simétricos no escalonamento, ilustrando a possibilidade da existência de vários blocos simétricos no escalonamento, Figura~\ref{fig:Sym-CDVAL} (b); a segunda delas apresenta uma solução ótima para o problema sem blocos simétricos no escalonamento, mas todo o escalonamento pode ser tratado como um único bloco simétrico, Figura~\ref{fig:Sym-CDVAL} (c).

\begin{figure}[htb]
\centering
\includegraphics[width=0.94\textwidth]{imagens/Sym-CDVAL.eps}
\caption{(a) Exemplo de uma instância de $8$ tarefas para o problema de escalonamento com penalidade de antecipação e atraso com uma solução ótima que contém um bloco simétrico no escalonamento (b) e outra solução ótima de mesmo custo sem blocos simétricos (c) com seus respectivos valores de antecipação e atraso e valores de critério de desempate.}
\label{fig:Sym-CDVAL}
\end{figure}

A Figura~\ref{fig:Simetria_CDVAL} (b) apresenta seis exemplos de soluções simétricas, que equivalem a solução ótima para a instância da Figura~\ref{fig:Simetria_CDVAL} (a), onde pode-se observar que apesar das soluções serem equivalentes, o valor de critério de desempate associado a cada solução é diferente. Dessa forma, a simetria lida apenas com a identificação de soluções equivalentes de modo que elas não precisem mais ser recalculadas no escalonamento, e o critério de desempate lida somente com soluções de mesmo custo no escalonamento e define qual das duas soluções com empate deve ser escolhida, escolhendo assim a solução que possuir o menor valor de critério de desempate.

\begin{figure}[htb]
\centering
\includegraphics[width=0.94\textwidth]{imagens/Simetria_CDVAL.eps}
\caption{Possíveis soluções ótimas simétricas para a instância apresentada em (a) com seus respectivos valores de função objetivo ($\sum{\alpha_{j}E_{j}} + \sum{\beta_{j}T_{j}}$) e valores de critérios de desempate (CD) apresentados em (b).}
\label{fig:Simetria_CDVAL}
\end{figure}

O estudo de ocorrência de simetria em problemas é foco de estudo há bastante tempo e recentemente vem ganhando uma importância ainda maior, principalmente no que tange ao desenvolvimento de métodos eficientes para a resolução de problemas computacionalmente difíceis, com o intuito justamente de minimizar o esforço necessário destes métodos na obtenção de boas soluções. Particularmente sobre problemas de escalonamento, Ostrowski et al.~\cite{Ostrowski:2010} apresentaram um estudo sobre remoção de simetria em problemas de escalonamento utilizando programação linear inteira e mostraram que estratégias de remoção de simetria podem representar um enorme ganho de desempenho nos métodos exatos. Os autores afirmam que a presença de simetria pode representar um efeito negativo no desempenho dos algoritmos exatos, citando pontualmente o método de enumeração implícita de \textit{branch-and-bound}, pois existem muitos subproblemas na árvore de \textit{branch-and-bound} que são equivalentes. Assim, é importante que esses subproblemas equivalentes sejam detectados, pois caso contrário, milhares de subproblemas desnecessários podem ser calculados, tornando problemas relativamente fáceis impossíveis de resolver através da técnica de \textit{branch-and-bound}. Para evitar que isso aconteça, as soluções equivalentes e subproblemas devem ser identificados e removidos da busca.


\section{Formulações matemáticas}

Nesta seção serão detalhadas as principais formulações matemáticas existentes na literatura para o problema de escalonamento clássico com penalidades de antecipação e atraso (tarefas independentes, com tempos arbitrários de processamento, sem preempção permitida, com datas de chegada iguais e datas de término distintas). Sendo assim, duas questões ajudam na classificação das formulações matemáticas existentes:
\begin{enumerate}
  \item permitem tempo ocioso no escalonamento ou não;
  \item consideram escalonamento em máquinas paralelas ou somente em uma única máquina.
\end{enumerate}

Kanet e Sridharan~\cite{Kanet:2000} apresentaram uma revisão da literatura sobre problemas de escalonamento com tempos ociosos inseridos, onde são considerados problemas de escalonamento que envolvem penalidades de antecipação e atraso, onde resumem os resultados gerais sobre quando considerar ou não tempo ocioso em problemas de escalonamento no geral. Assim, afirmam que não é necessário considerar ou tratar tempo ocioso nos dois seguintes casos: 

\begin{enumerate}
  \item Problemas de escalonamento em ambiente monoprocessado.
  \item Problemas de escalonamento em máquinas paralelas, quando todas as tarefas do problema estão simultaneamente disponíveis (quando se tem datas de chegadas iguais) e quando o problema de escalonamento apresentar medidas regulares de performance. 
\end{enumerate}


\subsection{Formulação de programação linear inteira mista para o escalonamento em máquinas paralelas com tempo ocioso (PIM-TO)} \label{Sched-ET-Form-1}

A primeira formulação considerada é o modelo de programação linear inteira mista (PIM) proposto por Arenales et al.~\cite{Arenales:2007} para o problema de escalonamento em máquinas paralelas. A formulação proposta assume que: todas as tarefas devem estar disponíveis no instante zero (datas de chegadas iguais, $r_j=0$, sem perda de generalidade); cada tarefa possui a sua própria data de término sugerida ($d_j$ distintos); qualquer máquina pode processar qualquer tarefa; cada tarefa pode ser executada somente uma vez; a preempção de uma tarefa não é permitida; cada máquina pode processar exatamente uma tarefa em um dado instante de tempo; o número de tarefas e máquinas são fixos e os tempos de processamento também são fixos. E apresenta tempos de preparação relacionadas a máquina e tarefas consecutivamente escalonadas.

A variável de decisão inteira é binária e tri-indexada, sendo: \textbf{$x_{ijk}$} que terá o valor $1$ se a tarefa $i$ precede imediatamente a tarefa $j$ na máquina $k$, $0$ caso contrário. As outras variáveis, que podem receber valores reais, são: \textbf{$C_{ik}$} que é o instante de término do processamento da tarefa $i$ na máquina $k$; e, \textbf{$T_i$} e \textbf{$E_i$} representam o atraso e a antecipação da tarefa $i$, respectivamente.

A formulação matemática também apresenta os seguintes parâmetros não-negativos: 
\begin{itemize}
   \item \textbf{$p_{ik}$} é o tempo de processamento da tarefa $i$ na máquina $k$ (para máquinas paralelas idênticas a notação muda para $p_{j}$);
   \item \textbf{$s_{ijk}$} é o tempo de preparação da máquina $k$ para processar a tarefa $j$ imediatamente após a tarefa $i$ (caso o problema não tenha tempos de preparação, assume-se o valor zero para o tempo de preparação da máquina);
   \item \textbf{$d_{j}$} é a data de entrega da tarefa $j$; e, \textbf{$M$} é uma constante suficientemente grande (conhecida pelo termo em inglês, \emph{big M}).
\end{itemize}

A seguir é apresentada a formulação matemática em programação inteira mista, com restrições e função objetivo lineares.

\setlength{\arraycolsep}{0.0em}
\begin{eqnarray}
\text{Min }& & \sum_{j = 1}^{n} ( E_{j} + T_{j} ) \label{MIP-ET1-1} \\
\text{S. a. }& & \sum_{k=1}^{m} \sum_{i=0}^{n} x_{ijk}  = 1 \hspace{1cm} j  = 1,2,...,n. \label{MIP-ET1-2} \\
&& \sum_{j=1}^{n} x_{0jk} \le 1 \hspace{1cm} k=1,2,...,m. \label{MIP-ET1-3}\\
&& \sum_{i=0, \hspace{0.2cm} i \neq h}^{n} x_{ihk} - \sum_{j=0, \hspace{0.2cm} j \neq h}^{n} x_{hjk} = 0 \hspace{1cm} h=1,...,n \text{  e  } k=1,...,m. \label{MIP-ET1-4} \\
&& C_{0k} = 0 \hspace{1cm} k=1,...,m. \label{MIP-ET1-5}\\
&& C_{jk} \ge C_{ik} - M + (p_{jk} + s_{ijk} + M)x_{ijk} \hspace{0.5cm} i=0,...,n; j=1,...,n \text{  e  } k=1,...,m. \hspace{1cm} \label{MIP-ET1-6}\\
&& E_{i} \ge d_{i} - C_{ik} \hspace{1cm} i=1,...,n \text{  e  } k=1,...,m. \label{MIP-ET1-7}\\
&& T_{i} \ge C_{ik} - d_{i} \hspace{1cm} i=1,...,n \text{  e  } k=1,...,m. \label{MIP-ET1-8}\\
&& T_{i} \ge 0, E_{i} \ge 0 \hspace{1cm} i=1,...,n. \label{MIP-ET1-9}\\
&& x_{ijk} \in \{0,1\} \hspace{1cm} i,j=0,...,n \text{  e  } k=1,...,m. \label{MIP-ET1-10}
\end{eqnarray}
\setlength{\arraycolsep}{5pt}

Na formulação acima, a função objetivo~\ref{MIP-ET1-1} minimiza a antecipação e o atraso das tarefas. As restrições~\ref{MIP-ET1-1}, ~\ref{MIP-ET1-2}, ~\ref{MIP-ET1-3} asseguram uma sequência exclusiva de tarefas para cada uma das máquinas. Sendo que o conjunto de restrições~\ref{MIP-ET1-2} indicam que cada tarefa $j$ na máquina $k$ tenha apenas uma tarefa precedente. O conjunto de restrições~\ref{MIP-ET1-3} garantem que cada máquina $k$, se usada, tenha uma sequência exclusiva de tarefas. O conjunto de restrições~\ref{MIP-ET1-4} definem que cada tarefa $j$ tenha uma única tarefa imediata sucessora, com exceção da tarefa $0$ que estabelece o início e o fim de uma sequência de tarefas na máquina $k$. Para a tarefa $0$, o conjunto de restrições~\ref{MIP-ET1-5} estabelecem que o instante de termino das tarefas nas máquinas devem ser iguais a zero. No conjunto de restrições~\ref{MIP-ET1-6} são verificados os instantes de conclusão das tarefas nas máquinas onde são executadas. Nas restrições~\ref{MIP-ET1-7} e~\ref{MIP-ET1-8}, são definidos, respectivamente, a antecipação e o atraso associado a cada uma das tarefas. As restrições~\ref{MIP-ET1-9} e \ref{MIP-ET1-10} indicam o domínio das variáveis utilizadas na formulação.

As restrições acima descritas não excluem a ocorrência de tempo ocioso entre as tarefas, como pode-se observar na Figura~\ref{fig:sched-example-MIP-ET-Arenales} (a), que apresenta uma solução viável para a instância da Figura~\ref{fig:Simetria_CDVAL} (a) e mostra que a aplicação da restrição~\ref{MIP-ET1-6} (Figura~\ref{fig:sched-example-MIP-ET-Arenales} (b)) permite tempo ocioso.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagens/sched-example-MIP-ET-Arenales.eps}
\caption{Solução do escalonamento de tarefas com tempo ocioso (a) e aplicação da restrição~\ref{MIP-ET1-6} para a solução (b).}
\label{fig:sched-example-MIP-ET-Arenales}
\end{figure}


\subsection{Formulação de programação linear inteira mista para o escalonamento em máquinas paralelas sem tempo ocioso (PIM-STO)} \label{Sched-ET-Form-2}

A segunda formulação considerada neste trabalho é o modelo de PIM proposto por Tsai e Wang~\cite{TsaiWang:2012} para máquinas paralelas não-relacionadas ($R || \sum_{i=1}^{n} T_{j} + \sum_{i=1}^{n} E_{j}$) baseado na formulação apresentada por Rabadi et al.~\cite{Rabadi:2006} para a minimização do \textit{makespan} em máquinas paralelas não-relacionadas. A formulação proposta por Tsai e Wang~\cite{TsaiWang:2012} também assume que: a formulação proposta assume que: todas as tarefas devem estar disponíveis no instante zero (datas de chegadas iguais, $r_j=0$, sem perda de generalidade); cada tarefa possui a sua própria data de término sugerida ($d_j$ distintos); qualquer máquina pode processar qualquer tarefa; cada tarefa pode ser executada somente uma vez; a preempção de uma tarefa não é permitida; cada máquina pode processar exatamente uma tarefa em um dado instante de tempo; o número de tarefas e máquinas são fixos e os tempos de processamento também são fixos e apresenta tempos de preparação relacionadas a máquina e tarefas consecutivamente escalonadas.

Apresenta a mesma variável de decisão inteira binária e tri-indexada, sendo: \textbf{$x_{ijk}$} uma variável binária que terá valor $1$ se a tarefa $j$ é processada diretamente depois da tarefa $i$ na máquina $k$, $0$ caso contrário (com os casos especiais para: \textbf{$x_{0jk}$},variável binária que terá valor $1$ se a tarefa $j$ é a primeira a ser processada na máquina $k$, $0$ caso contrário, e \textbf{$x_{i0k}$}, variável binária que terá valor $1$ se a tarefa $j$ é a última a ser processada na máquina $k$, $0$ caso contrário. As variáveis contínuas são: \textbf{$C_{j}$}, tempo de completude da tarefa $j$; \textbf{$T_{j}$}, atraso da tarefa $j$, e \textbf{$E_{j}$}, antecipação da tarefa $j$.

A formulação matemática também apresenta os seguintes parâmetros não-negativos: \textbf{$n$:} número de tarefas; \textbf{$m$:} número de máquinas; \textbf{$p_{jk}$:} tempo de processamento da tarefa $j$ na máquina $k$; \textbf{$d_{j}$:} data de término sugerida da tarefa $j$; e, \textbf{$M$:} uma constante suficientemente grande.

A seguir é apresentada a formulação matemática em programação inteira mista, com restrições e função objetivo lineares.

\setlength{\arraycolsep}{0.0em}
\begin{eqnarray}
\text{Min }& & \sum_{j = 1}^{n} E_{j} + \sum_{j = 1}^{n} T_{j} \label{MIP-ET-1} \\
\text{S. a. }& & \sum_{i=0, \hspace{0.2cm} i \neq j}^{n} \sum_{k=1}^{m} x_{ijk}  = 1 \hspace{1cm} j  = 1,2,...,n. \label{MIP-ET-2} \\
&& \sum_{i=0, \hspace{0.2cm} i \neq h}^{n} x_{ihk} - \sum_{j=1, \hspace{0.2cm} j \neq h}^{n} x_{hjk} = 0 \hspace{1cm} h=1,2,...,n;\  \ k=1,2,...,m. \label{MIP-ET-3}\\
&& C_{i} + \sum_{k=1}^{m} x_{ijk}(p_{jk}) + M(\sum_{k=1}^{m} x_{ijk} - 1) \le C_{j} \hspace{0.6cm} i=0,1,...,n;\  \ j=1,2,...,n. \hspace{0.6cm} \label{MIP-ET-4} \\
&& \sum_{j=0}^{n} x_{0jk} = 1 \hspace{1cm} k = 1,2,...,m. \label{MIP-ET-5}\\
&& T_{j} = C_{j} - d_{j} \hspace{1cm} j = 1,2,...,n. \label{MIP-ET-6}\\
&& E_{j} = d_{j} - C_{j} \hspace{1cm} j = 1,2,...,n. \label{MIP-ET-7}
\end{eqnarray}
\setlength{\arraycolsep}{5pt}


\setlength{\arraycolsep}{0.0em}
\begin{eqnarray}
&& C_{0} = 0 \label{MIP-ET-8}\\
&& C_{j}, E_{j}, T_{j} \ge 0 \hspace{1cm} j=1,2,...,n. \label{MIP-ET-9}\\
&& x_{ijk} \in \{0,1\} \hspace{0.3cm} i,j=1,2,...,n;\  \ k=1,2,...,m. \label{MIP-ET-10}\\
&& C_{0} + \sum_{k=1}^{m} x_{0jk}(p_{jk}) \ge C_{j} + M(\sum_{k=1}^{m} x_{0jk} - 1) \hspace{0.6cm} j=1,2,...,n. \label{MIP-ET-11}\\
&& C_{i} + \sum_{k=1}^{m} x_{ijk}(p_{jk}) \ge C_{j} + M(\sum_{k=1}^{m} x_{ijk} - 1) \hspace{0.6cm} i=0,1,...,n;\  \ j=1,2,...,n. \label{MIP-ET-12}
\end{eqnarray}
\setlength{\arraycolsep}{5pt}

Para adaptar o modelo para o problema envolvendo máquinas paralelas idênticas (e não o caso geral, de não-relacionadas), $P || \sum_{i=1}^{n} \alpha_j E_{j} + \sum_{i=1}^{n} \beta_j T_{j}$, a notação referente ao tempo de processamento das tarefas deve ser mudada de $p_{jk}$ (que indica que o tempo de processamento da tarefa $j$ será processada na máquina $k$) para somente $p_{j}$ (já que as máquinas são idênticas e não possuem desempenhos dependentes da tarefa a ser executada) e as penalidades de antecipação e atraso devem ser adicionadas na função objetivo, que fica como a seguir:

\begin{equation}
    \text{Min } \hspace{1cm} \sum_{j = 1}^{n} \alpha_j E_{j} + \sum_{j = 1}^{n} \beta_j T_{j} \\
\end{equation}

Na formulação acima, a função objetivo~\ref{MIP-ET-1} minimiza a antecipação e o atraso das tarefas. A restrição~\ref{MIP-ET-2} assegura que uma tarefa seja escalonada somente uma vez e processada por somente uma máquina. A restrição~\ref{MIP-ET-3} assegura que cada tarefa $i$ não seja nem precedida e nem sucedida por mais de uma tarefa $j$. A restrição~\ref{MIP-ET-4} é utilizada para calcular o tempo de completude das tarefas e assegurar que nenhuma tarefa $i$ deve preceder e suceder ao mesmo tempo uma determinada tarefa $j$ no escalonamento.

A restrição~\ref{MIP-ET-5} assegura que não mais que uma tarefa seja escalonada primeiro em uma máquina. O valores para atraso e antecipação das tarefas são calculados nas restrições~\ref{MIP-ET-6} e \ref{MIP-ET-7}, respectivamente. A restrição~\ref{MIP-ET-8} define o tempo de completude da tarefa fictícia $0$ seja zero. A restrição~\ref{MIP-ET-9} assegura que os valores para tempos de completude, antecipação e atraso sejam não-negativos. A restrição~\ref{MIP-ET-10} assegura que a variável de decisão $x_{ijk}$ seja binária.

As restrições acima descritas não excluem a ocorrência de tempo ocioso entre as tarefas, como pode-se observar na Figura~\ref{fig:sched-example-MIP-ET-IIT} (a), que apresenta uma solução viável para a instância da Figura~\ref{fig:Simetria_CDVAL} (a) e mostra que a restrição~\ref{MIP-ET-4} (Figura~\ref{fig:sched-example-MIP-ET-IIT} (b)) permite tempo ocioso.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagens/sched-example-MIP-ET-IIT.eps}
\caption{Escalonamento de tarefas: solução com tempo ocioso (a) e aplicação da restrição~\ref{MIP-ET-4} para a solução (b).}
\label{fig:sched-example-MIP-ET-IIT}
\end{figure}

Dessa forma, Tsai e Wang~\cite{TsaiWang:2012} propuseram mais duas novas restrições para solucionar o problema. A primeira proposta é a restrição~\ref{MIP-ET-11}, que assegura que o tempo de completude da primeira tarefa no escalonamento seja igual ao seu tempo de processamento. A Figura~\ref{fig:sched-example-MIP-ET-IIT2} (a) apresenta uma solução viável para a instância da Figura~\ref{fig:Simetria_CDVAL} (a) e mostra que a restrição~\ref{MIP-ET-11} (Figura~\ref{fig:sched-example-MIP-ET-IIT2} (b)) não permite tempo ocioso no início de uma sequência em cada máquina.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagens/sched-example-MIP-ET-IIT2.eps}
\caption{Escalonamento de tarefas: solução com tempo ocioso e com todas as tarefas iniciando no instante $0$ (a) e aplicação da restrição~\ref{MIP-ET-11} para a solução (b).}
\label{fig:sched-example-MIP-ET-IIT2}
\end{figure}

A segunda restrição~\ref{MIP-ET-12}, assegura que o tempo de completude de uma tarefa $j$ seja igual a soma do tempo de completude da tarefa que foi processada anteriormente a ele (tarefa $i$) com o seu tempo de completude. A Figura~\ref{fig:sched-example-MIP-ET} (a) apresenta uma solução viável para a instância da Figura~\ref{fig:Simetria_CDVAL} (a) e mostra que a restrição~\ref{MIP-ET-12} (Figura~\ref{fig:sched-example-MIP-ET} (b)) não permite tempo ocioso no escalonamento.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{imagens/sched-example-MIP-ET.eps}
\caption{Escalonamento de tarefas: solução sem tempo ocioso e com todas as tarefas iniciando no instante $0$ (a) e aplicação da restrição~\ref{MIP-ET-12} para a solução (b).}
\label{fig:sched-example-MIP-ET}
\end{figure}


\subsection{Formulação indexada pelo tempo para o escalonamento em ambiente monoprocessado (PI-STO-IT)} \label{Tanaka-form}

A terceira formulação considerada neste trabalho é um modelo de programação linear inteira (PI) proposto por Tanaka et al.~\cite{Tanaka:2009:EAS:1644424.1644462} para a minimização das penalidades de antecipação e atraso em ambiente monoprocessado (baseado nas formulações propostas por Pritsker et al.~\cite{pritsker:1968}, Dyer e Wolsey~\cite{Dyer:1990}, Sousa and Wolsey~\cite{Sousa:1992} e Van den Akker et al.~\cite{vandenAkker:1999}). 

Apresenta uma variável de decisão inteira binária e bi-indexada $x_{it}$ $(i \in N, 1 \le t \le T)$, tal que $x_{it}$ é igual a $1$ se $t \ge p_{i}$ e se a tarefa $i$ é completada no instante $t$ ($t = C_{i}$), e é igual a $0$, caso contrário.

Apresenta os seguintes parâmetros não-negativos: $p_j$, indicando o tempo de processamento da tarefa $j$; e, $T$ uma constante indicando o limite superior para o intervalo de tempo em que as tarefas devem ser escalonadas (intervalo de tempo entre $1$ e $T$.

Desta forma, o problema pode ser formulado como segue:

\setlength{\arraycolsep}{0.0em}
\begin{eqnarray}
\text{Min }& &\displaystyle \sum_{i = 1}^{n} \sum_{t = 1}^{T} f_{i}(t)x_{it} \label{lin-5} \\
\text{S. a. }& & \displaystyle \sum_{i=1}^{n} \sum_{s=t}^{min(T, \ \ t+p_{i}-1)}x_{is} = 1 \     \ 1 \le t \le T  \label{lin-6} \\
&&\displaystyle \sum_{t=1}^{T} x_{it} = 1 \ \ i \in N \label{lin-7} \\
&&\displaystyle x_{it} \in \{0, 1\}, \   \  i \in N, \   \ 1 \le t \le T \label{lin-8}
\end{eqnarray}
\setlength{\arraycolsep}{5pt}

A restrição (\ref{lin-6}) define a restrição de capacidade da máquina, onde cada máquina deve processar exatamente uma tarefa em um determinado instante de tempo. A restrição (\ref{lin-7}) indica o número de ocorrências das tarefas no escalonamento. Para a função objetivo~(\ref{lin-5}), minimização da antecipação e atraso, tem-se: $f_{j}(t) = \alpha_{i} \cdot max\{d_{i} - t, 0\} + \beta_{i} \cdot max\{t - d_{i}, 0\}$.


\subsection{Formulação clássica geral indexada pelo tempo para o escalonamento em ambiente monoprocessado (PI-TO-IT)} \label{Sched-Classic-Form}

A quarta formulação considerada se baseia na formulação geral proposta para problemas de escalonamento com funções objetivo regulares (não-decrescentes em relação aos tempos de completude das tarefas) proposta por Dyer e Wolsey~\cite{Dyer:1990}.
 
As variáveis de decisão são binárias bi-indexadas, $y_{j}^{t}$, indicando que uma tarefa $j$ inicia o seu processamento no instante $t$ em alguma máquina.

Apresenta os seguintes parâmetros não-negativos: $p_j$, indicando o tempo de processamento da tarefa $j$; e, $T$ uma constante indicando o limite superior para o intervalo de tempo em que as tarefas devem ser escalonadas (neste caso, intervalo de tempo entre $0$ e $T$.

Desta forma, o problema pode ser formulado como segue:

\setlength{\arraycolsep}{0.0em}
\begin{eqnarray}
\text{Min }& & \sum_{j \in J} \sum_{t=0}^{T - p_j} f_j(t + p_j) {y^t}_j \label{Classic-1} \\
\text{S. a. }& & \sum_{t=0}^{T - p_j} {y^t}_j = 1\ \ (\forall j  \in J) \label{Classic-2} \\
&& \sum_{\substack{j \in J,\\ t+p_j \le T}} \sum_{s = max\{0, t - p_j + 1\}}^{t} {y^s}_j \le 1 \  \ (t = 0, . . . , T - 1) \label{Classic-3}\\
&&\displaystyle {y^t}_j \in \{0,1\}\ \ (\forall j  \in J; t = 0, ..., T - 1) \label{Classic-4}
\end{eqnarray}
\setlength{\arraycolsep}{5pt}

Na função objetivo (\ref{Classic-1}), a função $f_j(x)$ é definida para cada tarefa, onde $x$ é o instante onde cada tarefa finaliza o seu processamento na linha do tempo. Se a função objetivo é para a minimização do atraso ponderado, por exemplo, $f_j(x)$ é igual a $\beta_j \times max\{0, x - d_j\}$. A restrição (\ref{Classic-2}) determina que a tarefa deve ser processada exatamente uma vez. A restrição (\ref{Classic-3}) determina que a máquina pode processar no máximo uma tarefa em um dado instante de tempo, sendo que a soma de tal instante com o seu respectivo tempo de processamento não pode ser maior que o máximo tempo de execução. Somente $1$ tarefas pode ser executada ao mesmo tempo (na única máquina disponível. Esta formulação pode ser adaptada para ambiente multiprocessado, trocando-se para $m$ o lado direito desta restrição, indicando que no pior caso, somente $m$ tarefas podem ser executadas ao mesmo tempo, onde $m$ é o número de máquinas disponíveis. A restrição (\ref{Classic-4}) define os tipos de variáveis utilizadas.
 
Uma vantagem importante da formulação indexada pelo tempo é que essa formulação pode ser utilizada para modelar vários critérios de desempenho, do tipo regulares (funções objetivo regulares) para problemas de escalonamento. A mudança na formulação se dá através da mudança dos custos da função objetivo. A desvantagem na utilização deste modelo é no tamanho: onde existem $n + T$ restrições e aproximadamente $nT$ variáveis, onde $T$ é a soma de todos os tempos de processamento $\sum_{j=1}^{n} p_{j}$ (para ambiente monoprocessado).

A Figura~\ref{fig:ClassicSched-example-1} apresenta uma solução viável em ambiente monoprocessado para a instância da Figura~\ref{fig:Simetria_CDVAL} (a). Para máquinas paralelas, Pessoa et al.~\cite{ArturEduardoMarcusRosiane:2010} definiu o valor de $T$ como $\lfloor (\sum_{j=1}^{n} p_{j} - p_{max})/m \rfloor + p_{max}$, onde $p_{max}$ é o maior tempo de processamento da tarefa, este valor é válido pois se uma tarefa $i$ é completada após $\lfloor (\sum_{j=1}^{n} p_{j} - p_{i})/m \rfloor + p_{i}$ em uma certa máquina, pode-se concluir que pelo menos uma outra máquina estará disponível no instante $\lfloor (\sum_{j=1}^{n} p_{j} - p_{i})/m \rfloor$, dessa forma, a tarefa pode ser movida para essa outra máquina, reduzindo assim o tempo de completude do escalonamento. Desta forma, instâncias com muitas tarefas, ou tarefas com um grande tempo de processamento, demandam muito tempo para solução.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{imagens/ClassicSched-example-1.eps}
\caption{Solução do escalonamento para ambiente monoprocessado.}
\label{fig:ClassicSched-example-1}
\end{figure}

A formulação indexada pelo tempo contou com uma adaptação para o problema de escalonamento com penalidades de antecipação e atraso na função objetivo. Apesar da formulação não permitir tempo ocioso na minimização do atraso ponderado de tarefas (funções regulares), é necessário que algumas restrições sejam adicionadas para evitar tempo ocioso na minimização da antecipação e atraso ponderados (funções não-regulares). As restrições a serem adicionadas seriam as que não permitissem tempo ocioso no início e no meio da sequência.

Assim, para evitar o tempo ocioso no início de uma sequência em uma determinada máquina, a restrição~\ref{Classic-1}, propusemos a seguinte restrição (Figura~\ref{fig:ClassicSched-example-P}):

\begin{equation}
   \sum_{j \in J} y_{j}^{0} = m. \label{Classic-5}
\end{equation}

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{imagens/ClassicSched-example-P.eps}
\caption{Solução do escalonamento com todas as tarefas iniciando no instante $0$ (a) e aplicação da restrição~\ref{Classic-5} para a solução (b).}
\label{fig:ClassicSched-example-P}
\end{figure}

Desta forma, todas as tarefas iniciam no instante zero. Entretanto, não foi definida ainda uma restrição que evite tempo ocioso entre as tarefas em uma determinada sequência de uma máquina nesta formulação.

Para evitar tempo ocioso entre as tarefas, foi proposta neste trabalho uma formulação de programação inteira que se baseia na adaptação da formulação clássica geral de escalonamento. A formulação proposta permite a utilização de funções objetivos não-regulares (não-crescentes em relação aos tempos de completude das tarefas) sem tempo ocioso entre as tarefas em ambiente mono e multiprocessado. 

Tempo ocioso nas máquinas não é permitido e as máquinas não podem processar mais que uma tarefa em um dado instante. Todas as tarefas podem ser processadas a partir do instante 0 (zero). Portanto, as tarefas devem ser processadas no intervalo de tempo $[0,T]$, onde $T = \left\lfloor\dfrac{\sum_{j=1}^{n} p_j - p_{max}}{m}\right\rfloor + p_{max}$, $p_{max}$ é o maior tempo de processamento de todas as tarefas e $m$ é o número de máquinas. As variáveis de decisão binárias $y_{j}^{t}$ indicam que a tarefa $j$ inicia o seu processamento no instante $t$ em alguma máquina. Desta forma, o problema pode ser formulado como segue (Formulação indexada pelo tempo baseada no modelo de fluxo em redes para o escalonamento em máquinas paralelas - PI-STO-JIT):

\setlength{\arraycolsep}{0.0em}
\begin{eqnarray}
\text{Min }& & \sum_{t=0}^{T} \sum_{j=1}^{n} f_j(C_j) {y^t}_j \label{Classic-01} \\
\text{S. a. }& & \sum_{t=0}^{T} {y^t}_j = 1 \hspace{0.2cm} (j = 1, 2, ..., n) \label{Classic-02} \\
&& \sum_{j=1}^{n} y_{j}^{t-p_{j}} - \sum_{j=0}^{n} y_{j}^{t} = 0  \hspace{0.2cm} (t = 1, . . . , T) \label{Classic-03}\\
&& \sum_{j=1}^{n} y_{j}^{0} = m  \label{Classic-04}\\
&&\displaystyle {y^t}_j \in \{0,1\} \hspace{0.2cm} (j = 1, 2, ..., n; t = 0, ..., T) \label{Classic-05}
\end{eqnarray}
\setlength{\arraycolsep}{5pt}

A função objetivo $f_j(C_j)$ (\ref{Classic-01}) desta formulação é baseada no problema $P||\sum{\alpha_{j}E_{j}} + \sum{\beta_{j}T_{j}}$. Assim, o valor de função objetivo pode ser calculado como segue: $f_j(C_j) = \sum{\alpha_{j} \cdot max\{0, d_j - C_j\}} + \sum{\beta_{j} \cdot max\{0, C_j - d_j\}}$. A restrição (\ref{Classic-02}) determina que a tarefa deve ser processada exatamente uma vez. A restrição (\ref{Classic-03}) determina a representação do escalonamento através de fluxo em redes, o que garante que não se tenha tempo ocioso entre as tarefas no escalonamento, neste caso, o tempo ocioso é permitido somente quando todas as tarefas em cada máquina são processadas, o tempo ocioso é representado pela tarefa fictícia 0 (zero), que é utilizada no final da sequência de tarefas em cada máquina, como esta tarefa fictícia é a última da sequência de tarefas, ela é direcionada ao instante final do escalonamento, essa restrição é ilustrada na Figura~\ref{fig:fluxo-Sched}. A restrição (\ref{Classic-04}) define o instante de início do escalonamento, no início do escalonamento é assegurado que a primeira tarefa da sequência em cada máquina comece no instante 0 (zero).

\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{imagens/res-fluxo.eps}
\caption{Esquema da restrição (\ref{Classic-03}) para a determinação da sequência de tarefas através de fluxo em redes.}
\label{fig:fluxo-Sched}
\end{figure}

A Figura~\ref{fig:exemplo-fluxo-redes-Classic-Sched} (b) apresenta o escalonamento utilizando a representação de fluxo em redes para a solução apresentada na Figura~\ref{fig:exemplo-fluxo-redes-Classic-Sched} (a), onde cada caminho é representado por diferentes setas na rede da Figura~\ref{fig:exemplo-fluxo-redes-Classic-Sched} (b), que indica uma sequência de tarefas em cada máquina.

\begin{figure}[ht]
\centering
\includegraphics[width=1.0\textwidth]{imagens/exemplo-fluxo-redes-Classic-Sched.eps}
\caption{(a) Solução utilizando o gráfico de Gannt. (b) representação do escalonamento no modelo de fluxo em redes para a formulação clássica do problema.}
\label{fig:exemplo-fluxo-redes-Classic-Sched}
\end{figure}


\subsection{Formulação baseada no modelo de fluxo em redes e roteamento de veículos para o o escalonamento em máquinas paralelas - \textit{Arc-time indexed formulation} (PI-STO-ArcTime)}

A quinta formulação, proposta por Pessoa et al.~\cite{ArturEduardoMarcusRosiane:2010} para a minimização do atraso ponderado de tarefas em ambiente mono e multiprocessado, baseia-se  no modelo de fluxo em redes e roteamento de veículos (\textit{Arc-time indexed formulation}) considera o escalonamento no intervalo de tempo de $0$ a $T$, onde as máquinas estão ociosas no instante $0$ e devem estar novamente ociosas no instante $T$. As variáveis binárias $x_{ij}^{t}$, $i \neq j$, indicam que a tarefa $i$ termina sua execução e a tarefa $j$ inicia a sua execução no instante $t$, em alguma máquina. As variáveis $x_{0j}^{t}$ indicam que a tarefa $j$ inicia seu processamento no instante $t$ em alguma máquina que estava ociosa no intervalo $t-1$ a $t$, em particular, as variáveis $x_{0j}^{0}$ indicam que a tarefa $j$ inicia em alguma máquina no instante $0$. As variáveis $x_{i0}^{t}$ indicam que a tarefa $i$ finaliza o seu processamento no instante $t$ em uma máquina que ficará ociosa nos instantes $t$ a $t + 1$, as variáveis $x_{i0}^{T}$ indicam que a tarefa $i$ será finalizada no instante final do intervalo de tempo. As variáveis $x_{00}^{t}$ indicam que o número de máquinas que estavam livres no intervalo $t-1$ a $t$ e irá permanecer ociosa no intervalo $t$ a $t+1$.

\setlength{\arraycolsep}{0.0em}
\begin{eqnarray}
\text{Minimizar }& &\displaystyle \sum_{j \in J_{+}} \sum_{j \in J \backslash \{i\}} \sum^{T - p_{j}}_{t = p_{i}} f_j(t + p_j) x_{ij}^{t} \label{lin-9} \\
\text{Sujeito a }& & \displaystyle \sum_{i \in J_{+} \backslash \{j\}} \sum^{T - p_{j}}_{t = p_{i}} x_{ij}^{t} = 1 \        \ (\forall j  \in J) \label{lin-10} \\
&&\displaystyle \sum_{j \in J_{+} \backslash \{i\}, \ \ t - p_{j} \ge 0} x_{ji}^{t} - \sum_{j \in J_{+} \backslash \{i\}, \ \ t + p_{i} + p_{j} \le T} x_{ij}^{t+p_{i}} = 0 \     \ (\forall j  \in J;  \label{lin-11} \\
&& t = 0, ..., T - p_{i}) \nonumber \\
&&\displaystyle \sum_{j \in J_{+}, \ \ t - p_{j} \ge 0} x_{j0}^{t} - \sum_{j \in J_{+}, \ \ t + p_{j} + 1 \le T} x_{0j}^{t+1} = 0 \     \ (t = 0, ..., T - 1) \label{lin-12} \\
&&\displaystyle \sum_{i \in J_{+}} x_{0j}^{0} = m \label{lin-13} \\
&&\displaystyle x_{ij}^{t} \in Z_{+} \      \ (\forall i \in J_{+}; \forall j \in J_{+} \backslash \{j\}; t = p_{i}, ..., T - p_{j}) \label{lin-14} \\
&&\displaystyle x_{00}^{t} \in Z_{+} \      \ (t = 0, ..., T - 1) \label{lin-15}
\end{eqnarray}
\setlength{\arraycolsep}{5pt}

As restrições (\ref{lin-11}), (\ref{lin-12}) e (\ref{lin-13}) definem o fluxo em redes de $m$ unidades (ou $m$ máquinas) em um grafo acíclico $G = (V,A)$. Neste fluxo existem apenas uma origem e um destino, qualquer solução pode ser decomposta em um conjunto de $m$ caminhos correspondentes a cada escalonamento (sequência de tarefas com seus tempos ociosos) de cada máquina. A restrição (\ref{lin-10}) define que cada tarefa deve estar em exatamente um caminho, e por isso, processada em somente uma máquina.

A Figura~\ref{fig:Arc-time-scheme} apresenta o escalonamento utilizando a representação de fluxo em redes e roteamento de veículos, para a instância apresentada na Figura~\ref{fig:Simetria_CDVAL} (a), onde cada caminho na rede representa o escalonamento em uma máquina.

\begin{figure}[ht]
\centering
\includegraphics[width=.96\textwidth]{imagens/arc-time-picture.eps}
\caption{Representação do escalonamento no modelo de fluxo em redes.}
\label{fig:Arc-time-scheme}
\end{figure}

Esta formulação foi adaptada para a minimização conjunta das penalidades de antecipação e atraso, sem tempo ocioso entre as tarefas, o tempo ocioso neste caso seria considerado somente após o fim da execução das tarefas nas máquinas.

A seguir são resumidas as principais características das formulações apresentadas. A Tabela~\ref{tab:DimFormulacoes} apresenta sete colunas: formulação matemática, número de restrições, número de variáveis, tipos de variáveis, ambiente de processamento, tipo de formulação e referência.

\begin{table}
  \centering
  \caption{Dimensão das formulações estudadas}
  \scalebox{0.73}{
  \begin{tabular}{p{2cm}p{1.8cm}p{1.8cm}p{2.5cm}p{2.7cm}p{2.5cm}p{4.4cm}}
    \toprule
    Formulação \linebreak Matemática & \centering Número de \linebreak restrições & \centering Número de \linebreak variáveis & \centering Tipos de \linebreak Variáveis & \centering Ambiente de \linebreak Processamento & \centering Tipo de \linebreak formulação & \multicolumn{1}{c}{Referência} \\
    \midrule
     PIM-TO & \centering   $O(n^{2}m)$   & \centering  $O(n^{2}m)$   & \centering mono, bi e tri-indexadas & \centering mono e multiprocessado   & \centering PIM  &  Arenales, Morabito, Armentano e Yanasse~(2007) \cite{Arenales:2007}  \\
     PIM-STO & \centering   $O(n^{2})$    & \centering  $O(n^{2}m)$   & \centering mono, bi e tri-indexadas & \centering mono e multiprocessado   & \centering PIM  &  Tsai e Wang~(2012) \cite{TsaiWang:2012}  \\
     PI-STO-IT & \centering   $O(n + T)$    & \centering  $O(nT)$       & \centering bi-indexadas & \centering monoprocessado           & \centering PI   &  Tanaka, Fujikuma e Araki~(2009) \cite{Tanaka:2009:EAS:1644424.1644462}  \\
     PI-TO-IT & \centering   $O(n + T)$    & \centering  $O(nT)$       & \centering bi-indexadas & \centering monoprocessado   & \centering PI   &  Dyer e Wolsey~\cite{Dyer:1990} e Pessoa, Uchoa, Aragão e Rodrigues~(2010) \cite{ArturEduardoMarcusRosiane:2010} \\
     PI-STO-ArcTime & \centering   $O(nT)$    & \centering  $O(n^{2}T)$       & \centering tri-indexadas & \centering mono e multiprocessado   & \centering PI   &  Pessoa, Uchoa, Aragão e Rodrigues~(2010) \cite{ArturEduardoMarcusRosiane:2010} \\
    \bottomrule
    \end{tabular}}%
  \label{tab:DimFormulacoes}%
\end{table}%

\section{Considerações finais}

Este capítulo apresentou uma revisão da literatura envolvendo problemas de escalonamento de tarefas com penalidades de antecipação e atraso, considerando os ambientes mono e multiprocessado. Foram apresentadas as definições e conceitos principais, notação clássica e exemplos de aplicação juntamente com propriedades estruturais que definem um escalonamento ótimo. Uma análise das formulações matemáticas para os problemas de escalonamento E/T foi apresentada, onde foi proposta uma formulação para o problema de escalonamento com antecipação e atraso em ambientes mono e multiprocessado sem tempo ocioso entre as tarefas. Esta formulação foi baseada na formulação clássica geral indexada pelo tempo de Dyer e Wolsey~\cite{Dyer:1990} e em um modelo de fluxo em redes.