\chapter{Métodos propostos} \label{chap-MetProp}

Neste capítulo são detalhadas cinco estratégias algorítmicas aproximadas para o problema de escalonamento de tarefas que envolve penalidades de antecipação e atraso. Estas estratégias são baseadas em otimização global com busca simples (\textit{single-start}) ou busca múltipla (\textit{multi-start}) e baseadas em busca local com reconexão de caminhos, cujo objetivo foi analisar o processo de convergência, tempo de execução e a qualidade das soluções obtidas, afim de se atingir as melhores soluções possíveis. Os métodos propostos neste trabalho são resumidos a seguir: 

\begin{itemize}
   \item \textbf{Otimização global com busca simples:}
            \begin{enumerate}
                \item  Busca local iterada - ILS;
                \item  Busca local iterada com reconexão de caminhos - ILS+PR.
            \end{enumerate}

	\item \textbf{Otimização global com busca múltipla baseada em população:}
            \begin{enumerate}
                \item  Algoritmo genético com reconexão de caminhos - GA+PR;
                \item  Algoritmo genético com busca local e reconexão de caminhos - GA+LS+PR.
            \end{enumerate}

	\item \textbf{Otimização global com busca múltipla baseada em um conjunto de soluções:}
            \begin{enumerate}
                \item  Algoritmo ILS busca múltipla - ILS-M.
            \end{enumerate}
\end{itemize}


O primeiro método envolve uma adaptação do algoritmo de \textit{busca local iterada}, proposto inicialmente por Rodrigues et al.~\cite{RosianeArthurEduardoMarcus:2008} para a minimização do atraso ponderado de tarefas. Este método iterativo é baseado em otimização global com busca simples, onde a cada iteração, a solução corrente é substituída por uma solução vizinha de melhor qualidade, usando a representação de uma lista sequencial para o escalonamento em múltiplas máquinas e vizinhança baseada no 2-Opt com movimentos generalizados de troca de pares e critério de desempate. A segunda estratégia algorítmica proposta envolve \textit{busca local iterada com a técnica de reconexão de caminhos} [Amorim et al.~\cite{amorim-dias-rodrigues:2012}], cujo objetivo é encontrar melhores soluções no espaço de busca formado entre dois ótimos locais.

As outras três estratégias propostas foram baseadas em otimização global com busca múltipla utilizando o \textit{Algoritmo Genético} como base. Assim, a terceira estratégia algorítmica envolve o \textit{Algoritmo Genético com reconexão de caminhos}, cujo objetivo é verificar se a técnica de reconexão de caminhos consegue explorar e atingir boas soluções entre soluções arbitrárias da população gerada. A quarta estratégia proposta combina o \textit{Algoritmo Genético usando Busca Local com reconexão de caminhos}, cujo objetivo é melhor explorar o espaço de busca entre soluções ótimas locais, como no método da \textit{busca local iterada com a técnica de reconexão de caminhos}, mas agora com otimização global com busca múltipla, afim de convergir rapidamente para melhores soluções, mesmo em instâncias maiores. Nas duas abordagens é gerada uma nova população com soluções cada vez melhores e diversificadas a cada iteração. A quinta e última estratégia algorítmica proposta envolve ILS com busca múltipla, onde o objetivo é verificar se o ILS consegue atingir melhores soluções, em instâncias de tamanho maior, considerando um conjunto de soluções diversificadas a cada iteração.

Além dos métodos aproximados propostos, o método exato considerado neste trabalho envolveu a utilização do algoritmo \textit{branch-and-cut} da ferramenta IBM/ILOG CPLEX 12.4, onde foi considerada a implementação da formulação de programação inteira proposta neste trabalho (PI-STO-JIT), utilizando-se a biblioteca UFFLP, que ajudou no processo de conversão das instâncias de teste e resolução do modelo matemático utilizando o ambiente CPLEX como resolvedor. Nas seções seguintes, os métodos propostos são detalhados.

\pagebreak

\section{Busca local iterada - ILS} \label{sec:ILS}

A primeira abordagem algorítmica trata-se do algoritmo de Busca Local Iterada (ILS) para o problema de escalonamento com antecipação e atraso ponderados, $P||\sum \alpha_{j} E_{j} + \beta_{j} T_{j}$, baseado no método ILS proposto inicialmente por Rodrigues et al.~\cite{RosianeArthurEduardoMarcus:2008} para o problema de escalonamento com atraso ponderado em máquinas paralelas ($P || \sum w_j T_j$). 

A ideia principal da heurística de Rodrigues et al.~\cite{RosianeArthurEduardoMarcus:2008} é representar um escalonamento mínimo para o problema com atraso total ponderado de tarefas como uma lista sequencial de tarefas. A Figura~\ref{fig:Single-Gantt-chart} ilustra a representação da solução utilizada pela heurística para minimização das penalidades de antecipação e atraso de tarefas, onde a Figura~\ref{fig:Single-Gantt-chart} (b) mostra a representação do escalonamento através de uma lista sequencial de tarefas utilizada pelo algoritmo, que trata-se somente de uma permutação do conjunto de tarefas para o ambiente monoprocessado. O algoritmo consegue atingir soluções ótimas para instâncias com $40$ e $50$ tarefas. A seguir serão considerados os detalhes dessa heurística de busca local para o problema de escalonamento com antecipação e atraso.

\begin{figure}[ht]
\centering
\includegraphics[width=.91\textwidth]{imagens/Single_Gantt_Chart_scheduling.eps}
\caption{Representação da solução utilizada pelo algoritmo de busca local iterada de Rodrigues et al.~\cite{RosianeArthurEduardoMarcus:2008} para o escalonamento E/T, onde tem-se: (a) uma instância de $8$ tarefas. (b) a representação do escalonamento através de uma lista sequencial e a sua respectiva representação em máquinas paralelas idênticas em (c).}
\label{fig:Single-Gantt-chart}
\end{figure}

O Algoritmo~\ref{code:algoRodriguesetal2008} apresenta uma adaptação da heurística de Rodrigues et al.~\cite{RosianeArthurEduardoMarcus:2008} para a minimização das penalidades de antecipação e atraso. Onde $N$ é o número de iterações, $r$ é o número de vezes que uma permutação aleatória é gerada e $k$ é o número de movimentos generalizados de troca de pares (\textit{generalized pairwise interchange} - GPI) aplicados a solução $\pi$ (solução apresentada na Figura~\ref{fig:Single-Gantt-chart} (b)). 

Os movimentos GPI são definidos por dois tipos de movimentos, o primeiro deles é o movimento de troca (\textit{swap}), onde a posição das duas tarefas $i$ e $j$ (não necessariamente adjacentes) na sequência é trocada em $\pi$, Figura~\ref{fig:gpi-moves} (a); e o segundo deles é o movimento de remoção (\textit{move}), onde a tarefa $i$ é removida de sua posição original e inserida na posição da tarefa $j$ em $\pi$, a subsequência de tarefas entre as tarefas $i$ e $j$ são reposicionadas para dar espaço a tarefa $i$ na sua nova posição, Figura~\ref{fig:gpi-moves} (b). Cada busca local é realizada até que não seja mais possível melhorar a solução corrente. Um busca completa na vizinhança custa $O(n^{2})$ movimentos GPI e o custo de transformar uma lista sequencial no escalonamento para máquinas paralelas é de $O(nlogm)$.

Seja uma solução inicial $s$ para o problema $1||\sum{\alpha_{j} E_{j}} + \sum{\beta_{j} T_{j}}$, obtida por uma permutação inicial $\pi$ de tarefas, $\pi = (\pi_{1}, \pi_{2}, ..., \pi_{n})$,  onde todas as máquinas estão ociosas no instante $0$.
Assim, a partir desta solução inicial $\pi$, uma solução factível é gerada através do sequenciamento de tarefas da menor para a maior data de término sugerida (\textit{earliest due date} - EDD) e é armazenada em $\pi^{*}$. Na primeira iteração, é gerada uma permutação aleatória em $\pi$.

\begin{algorithm}
  $i \leftarrow 1$\; % \Comment{Write a comment here}
  $\pi^{*} \leftarrow $ uma permutação gerada pelo sequenciamento de tarefas da menor para a maior data de término sugerida\;
  \Enqto{$i < N$}{
      \Se{$i$ \textbf{é um múltiplo de} $r$}{
           $\pi \leftarrow $ \textbf{uma permutação aleatória}\;
      }
      Aplique movimentos GPI em $\pi$, até que não seja possível melhorar o valor de $\sum{\alpha_{j} E_{j}} + \sum{\beta_{j} T_{j}}$\;
      \Se{$w(\pi) < w(\pi^{*})$}{
           $\pi^{*} \leftarrow \pi$\;
      }
      Aplique $k$ movimentos de troca escolhidos aleatoriamente em $\pi$\;
      $i \leftarrow i + 1$.
  }
\caption{Adaptação do algoritmo de busca local iterada de Rodrigues et al.~\cite{RosianeArthurEduardoMarcus:2008} para a minimização das penalidades de antecipação e atraso.}
\label{code:algoRodriguesetal2008}
\end{algorithm}


A busca na vizinhança é baseada em movimentos GPI e a busca na vizinhança da solução $\pi$ termina quando o primeiro movimento de melhora é achado - neste caso, $\pi$ é atualizado e uma nova busca é iniciada. Isto é feito até que uma busca seja completada sem melhorias. Se a solução achada na busca local for melhor que a melhor solução global atual, então a mesma será armazenada como $\pi^{*}$. Finalmente, $k$ movimentos GPI escolhidos aleatoriamente são aplicados em uma tentativa de sair de regiões de ótimo local ruins. A cada $r$ iterações, uma nova permutação totalmente aleatória substitui a solução gerada na iteração anterior. Uma busca completa na vizinhança requer um tempo de $O(n^2)$ movimentos, e a avaliação de cada movimento requer a construção do escalonamento usando a regra de despacho, o que requer tempo $O(n\ \log m)$ em uma implementação com filas de prioridade.

\begin{figure}[ht]
\centering
\includegraphics[width=.6\textwidth]{imagens/move_swap.eps}
\caption{Exemplo de movimentos generalizados de troca de pares: (a) movimento de troca e (b) movimento de remoção.}
\label{fig:gpi-moves}
\end{figure}

A busca local conta com a estratégia da melhor solução encontrada (\textit{best improvement}), ou seja, a mudança é aceita somente quando a nova solução é melhor que a solução corrente. Entretanto, soluções ótimas locais geralmente possuem muitas soluções vizinhas com o mesmo custo. Dessa forma, para impedir uma busca prematura, ou seja, para que o algoritmo continue efetuando a busca por soluções melhores, o algoritmo possui um Critério de Desempate (seção~\ref{Section:CDVAL}) de soluções que define, dentre outras soluções de mesmo valor de função objetivo, qual deve ser considerada a melhor solução. Quando há algum empate entre máquinas, ou seja, quando se tem duas máquinas ociosas, é escolhida a máquina com o menor índice.

O processo de busca local é repetido durante $x$ iterações, onde $x = k \cdot n \cdot m$, onde $k$ é uma dada constante, $n$ é o número de tarefas e $m$ é o número de máquinas. Quando o número da iteração corrente é um múltiplo de uma dada constante $r$, uma nova sequência randômica é gerada onde a busca local será aplicada novamente. Finalmente, $k$ movimentos GPI escolhidos aleatoriamente são aplicados em uma tentativa de explorar outras sub-regiões do espaço de busca e fugir de ótimos locais.


\section{Busca local iterada com reconexão de caminhos entre soluções ótimas locais - ILS+PR} \label{secPR+ILS}

A segunda abordagem algorítmica aplicada problema de escalonamento E/T consiste na combinação do algoritmo ILS com a técnica de reconexão de caminhos (\textit{path relinking}), técnica que foi originalmente proposta para diversificação do algoritmo \textit{scatter search}~\cite{Glover00}. Com essa estratégia combinada, é possível convergir rapidamente para bons resultados do que o algoritmo ILS sozinho, e assim obter melhores soluções para instancias maiores.

O método ILS+PR começa o seu processamento com duas soluções viáveis, essa soluções são geradas através de uma permutação randômica das sequências únicas seguindo a regra de sequência de tarefas da menor para a maior data de término sugerida (EDD). Em seguida, o algoritmo realiza uma busca local sobre as duas soluções viáveis. Após a busca local, tem-se duas soluções ótimas locais, e a técnica de reconexão de caminhos é aplicada com o objetivo de se explorar o espaço de soluções existente entre os dois ótimos locais. Com essa estratégia foi possível provar que existem melhores soluções no espaço de busca entre dois ótimos locais.

Na implementação proposta, a técnica de reconexão de caminhos começa a sua execução a partir da melhor solução ótima local, da iteração, para a pior solução ótima local, essa estratégia é conhecida como \textbf{reconexão de caminhos reversos} (\textit{backward path relinking}). A melhor solução encontrada no caminho é armazenada e, finalmente, as três soluções (duas soluções obtidas por buscas locais e uma solução obtida pela reconexão de caminhos) são comparadas entre si e a melhor solução global (solução corrente do algoritmo). A melhor solução entre as três soluções candidatas é então considerada a melhor nova solução global, como pode ser observado no esquema da Figura~\ref{fig:ILS+PR} (b), que considera a instância apresentada na Figura~\ref{fig:ILS+PR} (a) e, como ambiente de processamento, foram utilizadas duas máquinas paralelas idênticas.

\begin{figure}[ht]
\centering
\includegraphics[width=.99\textwidth]{./imagens/Reconexao-Caminhos.eps}
\caption{(a) Exemplo de instância para o algoritmo de reconexão de caminhos. (b) esquema para o algoritmo de reconexão de caminhos reversos (\textit{backward path relinking}), onde as soluções com as setas rachuradas representam o caminho percorrido de melhores soluções no espaço de soluções existente entre as duas soluções iniciais, melhor solução e solução guiada.}
\label{fig:ILS+PR}
\end{figure}

Na técnica de reconexão de caminhos, a melhor solução das duas soluções viáveis iniciais encontradas (ótimos locais) é guardada. Esta solução, que será chamada de \textbf{caminho de sequência}, será alterada para se tornar igual à solução guiada. O algoritmo então verifica, para cada posição do caminho de sequência, uma solução que, quando alterada, se torne igual a solução guiada, retornando assim a melhor solução.

Dessa forma, para fazer a posição $j$ no caminho de sequência $\theta$ se tornar igual à posição $j$ da solução guiada $\pi$, deve-se encontrar a posição $k$ do elemento $\pi_i$ no caminho de sequência. Encontrada a posição $k$, os elementos $\theta_i$ e $\theta_j$ são trocados no caminho de sequência. Assim, quando o melhor movimento é encontrado no caminho de sequência, e quando a posição do caminho de sequência se torna igual a posição da solução guiada, esta posição é marcada como fixa e não será mais modificada. Este procedimento é repetido até que todas as posições se tornem fixas ($n$ iterações).

Para ajudar o algoritmo de reconexão de caminhos explorar cada vez mais o espaço de soluções, a cada cinco iterações do algoritmo é realizada uma perturbação na solução global de forma a sempre ser possível buscar uma nova e extensa área do espaço de soluções, que pode ser explorada por esses procedimentos (duas buscas locais e reconexão de caminhos). O Pseudocódigo para este algoritmo melhorado integrando busca local iterada e reconexão de caminhos é apresentado no Algoritmo~\ref{alg:ILS-PR} e o pseudocódigo que detalha a técnica de reconexão de caminhos é apresentado no Algoritmo~\ref{alg:PR}.


\begin{algorithm}
 \caption{ILS para o problema $1||\sum{\alpha_{j}E_{j}} + \sum{\beta_{j}T_{j}}$ com reconexão de caminhos reversos.}
 \label{alg:ILS-PR}
 $i \leftarrow 1$\;
 $\pi \leftarrow$ uma permutação seguindo a regra da menor para a maior data de término sugerida\;
 $\theta \leftarrow$ uma permutação randômica de $\pi$\;
 $\pi^{*} \leftarrow $ melhor solução corrente\;
 \Enqto{$i < N$}{
	  \Se {$i > 0$}{
		    $\pi$ e $\theta \leftarrow $ permutações randômicas de $\pi$ e $\theta$\;
		  }
	      Aplique movimentos generalizados de troca de pares em $\pi$ e em $\theta$, até que não seja possível melhorar o valor de $\sum{\alpha_{j} E_{j}} + \sum{\beta_{j} T_{j}}$\;
	      \Se{$w(\pi) < w(\theta)$}{
	          $\gamma \leftarrow$ Reconexão-de-caminhos($\pi, \theta$)\;
	      }
	      \Senao{
	          $\gamma \leftarrow$ Reconexão-de-caminhos($\theta, \pi$)\;
	      }
	      \Se{$w(\pi) < w(\theta)$ \textbf{e} $w(\pi) < w(\gamma)$}{
	          	\Se {$w(\pi) < w(\pi^{*})$}{
	               $\pi^{*} \leftarrow \pi$\;
	            }
	            \Senao{
	               \Se {$w(\theta) < w(\pi)$ \textbf{e} $w(\theta) < w(\gamma)$}{
		          	    \Se {$w(\theta) < w(\pi*)$}{
		          	       $\pi^{*} \leftarrow \theta$\;
		          	    }
		                \Senao{
		                  \Se {$w(\gamma) < w(\pi*)$}{
		                    $\pi^{*} \leftarrow \gamma$\;
		                  }
		                }
	               }
	            }
	       }
	       $i \leftarrow i + 1$\;
  }
\end{algorithm}


\begin{algorithm}
 \caption{Reconexão-de-caminhos(Início,SoluçãoGuiada).}
 \label{alg:PR}
 \Entrada{Início,SoluçãoGuiada}
 \Saida{MelhorEncontrado}
 \BlankLine
	
 Caminho $\leftarrow$ Início\;
 Contador $\leftarrow 1 $\;
 MelhorSoluçãoEncontrada $ \leftarrow \infty$\;
 \Enqto{Contador $\le n$}{
	\textit{MelhorSoluçãoAlterada} $ \leftarrow \infty$\;
	\Enqto{$j \le n$}{
		\Se {$j$ não é fixo}{
			$k \leftarrow$ posição da SoluçãoGuiada$_j$ no Caminho\;
			Troque Caminho$_j$ e Caminho$_k$\;
			\Se {$w(caminho) < $ MelhorSoluçãoAlterada}{
				MelhorJ $\leftarrow j$\;
				MelhorK $\leftarrow k$\;
				MelhorSoluçãoAlterada $\leftarrow w(caminho)$\;
			}
			Troque Caminho$_k$ e Caminho$_j$\;
		}
	}
	Troque Caminho$_{MelhorJ}$ e Caminho$_{MelhorK}$\;
	\Se{$w(caminho) < $ MelhorSoluçãoEncontrada}{
		MelhorEncontrado $\leftarrow$ Caminho\;
		MelhorSoluçãoEncontrada $\leftarrow w(caminho)$\;
	}
	Marque $j$ como fixo\;
	Contador $\leftarrow$ Contador $+ 1$\;
 }
\end{algorithm}


\pagebreak

\section{Algoritmo genético com reconexão de caminhos entre soluções arbitrárias - GA+PR} \label{secPR+GA}

O terceiro método proposto neste trabalho envolve o algoritmo genético (GA) com Reconexão de Caminhos entre soluções arbitrárias (e o último método proposto é entre ótimos locais).

Neste algoritmo também é utilizada a representação em lista sequencial para o escalonamento de tarefas de Rodrigues et al.~\cite{RosianeArthurEduardoMarcus:2008} (Figura~\ref{fig:Single-Gantt-chart} (b)). Esta sequência é tratada como como um cromossomo que é utilizado nas operações do algoritmo (\textbf{cruzamento baseado em posição} e \textbf{mutação}). Cada gene representa uma tarefa e cada iteração do algoritmo uma nova população é gerada, conforme ilustrado na Figura~\ref{fig:GA}. Quando é necessário calcular o valor de função objetivo (\textit{fitness}) de um cromossomo (solução), as tarefas são distribuídas nas máquinas e o valor de antecipação e atraso ponderados das tarefas é calculado (Figura~\ref{fig:Single-Gantt-chart} (c)). O algoritmo foi baseado nas operações genéticas propostas por Liu et al.~\cite{Liu:2005}, proposto inicialmente para a minimização o atraso ponderado de tarefas em ambiente monoprocessado ($1 || \sum{w_{j} T_{j}}$). A seguir serão detalhadas as operações genéticas e estratégias desenvolvidas.

\begin{figure}[ht]
\centering
\includegraphics[width=.95\textwidth]{./imagens/GA.eps}
\caption{Estratégia do Algoritmo Genético proposto, onde a cada iteração uma nova população é gerada.}
\label{fig:GA}
\end{figure}


\subsection{Função de avaliação (\textit{fitness})}
Utilizando a abordagem de lista sequencial, apresentada na Figura~\ref{fig:Single-Gantt-chart} (b), o cromossomo é codificado através de movimentos GPI com cada gene sendo uma tarefa que deve ser escalonada na máquina disponível mais cedo, como apresentado na Figura~\ref{fig:Single-Gantt-chart} (c). Quando uma população é gerada, cada cromossomo é avaliado de acordo com o seu valor de função de avaliação, que trata-se do valor de função objetivo com as penalidades de antecipação e atraso para cada cromossomo.


\subsection{Operações genéticas}
\begin{itemize}
  \item[a)] \textbf{Cruzamento (\textit{crossover}):} a regra de operação de cruzamento é a de combinar elementos de dois cromossomos pais e gerar um ou mais cromossomos filhos. Foi utilizado o \textbf{cruzamento baseado em posição}, onde as posições são randomicamente escolhidas (são escolhidas $0.4*n$ posições, onde $n$ é o número de tarefas), e as características (genes) nesta posição são guardadas e a descendência é mantida intacta. A Figura~\ref{fig:crossover} mostra um exemplo de cruzamento para duas soluções da instância apresentada na Figura~\ref{fig:Single-Gantt-chart} (a), onde os dois pais (\textbf{A} e \textbf{B}) foram escolhidos pela estratégia de seleção por torneio, e mostra os dois filhos gerados (\textbf{C} e \textbf{D}) pelo cruzamento;
\end{itemize}

\begin{figure}[ht]
\centering
\includegraphics[width=.8\textwidth]{./imagens/crossover.eps}
\caption{Operações Genéticas de cruzamento realizadas pelo algoritmo.}
\label{fig:crossover}
\end{figure}

\begin{itemize}
  \item[b)] \textbf{Mutação:} A regra da operação de mutação é prover e manter a diversidade em uma população tal que os operadores podem continuar trabalhando. A mutação utilizada no algoritmo é a mutação baseada em ordem, onde duas posições são selecionadas randomicamente, e assim, as características (genes) destas posições são trocadas. A seleção por torneio também é utilizada pela operação de mutação, mas apenas um indivíduo é selecionado para receber a mutação, a Figura~\ref{fig:mutacao} mostra um exemplo de mutação para uma solução da instância da Figura~\ref{fig:Single-Gantt-chart} (a).
\end{itemize}

\begin{figure}[ht]
\centering
\includegraphics[width=.45\textwidth]{./imagens/mutacao.eps}
\caption{Operações Genéticas de Mutação realizadas pelo algoritmo.}
\label{fig:mutacao}
\end{figure}

Assim, após a operação genética de cruzamento, onde geram-se dois novos descendentes (ou soluções arbitrárias), outra técnica pode ser aplicada com objetivo de intensificar o processo de busca por melhores soluções. Dessa forma, foi desenvolvido um passo extra onde as novas soluções descendentes geradas são utilizadas pelo algoritmo de reconexão de caminhos, onde, a melhor solução das duas soluções candidatas é utilizada como solução inicial e a pior delas é utilizada como solução guiada, a melhor solução encontrada no algoritmo de reconexão de caminhos é guardada na nova população, de acordo com o esquema da Figura~\ref{fig:Cruz-PR} (sem o passo da busca local - que será detalhado na seção seguinte). A estratégia utilizada neste algoritmo é a estratégia de substituição de gerações, onde a cada iteração, uma nova população é gerada, e se nesse processo for encontrada uma solução melhor que a solução global corrente, a melhor solução encontrada é assumida como nova solução global. O Algoritmo~\ref{code:genetic+pr} apresenta a ideia proposta.


\begin{figure}[ht]
\centering
\includegraphics[width=.95\textwidth]{./imagens/Cruz-PR.eps}
\caption{Esquema da operação de cruzamento seguida reconexão de caminhos entre soluções arbitrárias.}
\label{fig:Cruz-PR}
\end{figure}


\begin{algorithm}
\caption{Algoritmo Genético com Reconexão de Caminhos entre soluções arbitrárias para o escalonamento de máquinas
paralelas.}
\label{code:genetic+pr}
     
     $\prod \longleftarrow$ um conjunto de permutações aleatórias geradas de tarefas\;
     Calcule os valores de \textit{fitness} de cada permutação\;
     \Enqto{$i < N$}{
          $\prod^{*} \longleftarrow$ melhores soluções de $\prod$ \Comment{Elitismo}\;

          $\prod^{*} \longleftarrow$ \textit{Mutação} na solução $\pi$\;
          
          $\prod^{*} \longleftarrow$ \textit{Cruzamento} usando as soluções $\pi$ e $\theta$\;
          
          $\prod^{*} \longleftarrow$ \textit{Cruzamento com Busca Local} usando as soluções $\pi$ e $\theta$\;

          $\pi^{*}$ e $\theta^{*}$ $\longleftarrow$ \textit{Cruzamento baseado em posição} em $\pi$ e $\theta$\;

          \Se{$w(\pi^{*}) < w(\theta^{*})$}{
	          $\prod^{*} \longleftarrow$ \textbf{Reconexão-de-Caminhos}($\pi^{*}, \theta^{*}$)\;
	      }
	      \Senao{
	          $\prod^{*} \longleftarrow$ \textbf{Reconexão-de-Caminhos}($\theta^{*}, \pi^{*}$)\;
	      }
          $i \longleftarrow i + 1$\;
     }
     Retorne a melhor solução encontrada.

\end{algorithm}



\section{Algoritmo genético com reconexão de caminhos entre ótimos locais - GA+LS+PR} \label{sec:GA+LS+PR}

O quarto método proposto envolve uma estratégia algorítmica com algoritmo genético com busca local e a técnica de reconexão de caminhos (GA+LS+PR). Dessa forma, dada a performance do algoritmo da heurística de busca local, agora o algoritmo genético proposto possui dois passos extras: para cada descendente gerado no cruzamento, é realizada uma busca local com o objetivo de melhorar cada vez mais a geração de novos indivíduos na população, esta abordagem pode reduzir o tempo necessário para se atingir uma solução ótima ou próximo do ótimo, e para o segundo passo, após a busca local nos novos descendentes gerados, tem-se dois ótimos locais, esses dois ótimos locais são utilizados na técnica de reconexão de caminhos e a melhor solução encontrada no caminho é armazenada na nova população (população que será utilizada na próxima iteração do algoritmo). Juntamente com o Elitismo, operações genéticas (mutação e cruzamento) e agora, com busca local e o passo de reconexão de caminhos, a cada iteração, é gerada uma nova população onde é possível obter boas soluções que jamais são perdidas no processo evolucionário. A Figura~\ref{fig:Cruz-LS-PR} apresenta o esquema do Algoritmo Genético com Busca Local e Reconexão de Caminhos proposto.

\begin{figure}[ht]
\centering
\includegraphics[width=.95\textwidth]{./imagens/Cruz-LS-PR.eps}
\caption{Esquema da operação de cruzamento seguida de busca local e reconexão de caminhos entre ótimos locais.}
\label{fig:Cruz-LS-PR}
\end{figure}

O Algoritmo~\ref{code:genetic+ls+pr} apresenta os passos gerais da ideia proposta, onde a cada iteração a população é ordenada de acordo com o valor de função objetivo (da melhor para a pior solução), e somente as melhores soluções são copiadas para a nova população do algoritmo, garantindo assim o \textbf{\textit{Elitismo}} da população. A seguir, é realizada uma seleção por torneio para selecionar os pais para operações genéticas (um indivíduo para \textit{mutação} e dois para \textit{cruzamento}). O cruzamento é realizado novamente com o objetivo de selecionar dois descendentes que serão utilizados pelo algoritmo de reconexão de caminhos afim de explorar o espaço de soluções entre estes dois descendentes. Enquanto as novas soluções são geradas, estas novas soluções são guardadas em uma nova população ou população auxiliar de modo que essa nova população seja utilizada na próxima iteração do algoritmo. Se alguma melhor solução for encontrada durante esse processo, a melhor solução global do algoritmo é substituída com a nova melhor solução encontrada. Através desta abordagem é possível obter novas soluções e melhores soluções em um razoável período de tempo, melhor que os outros métodos propostos.


\begin{algorithm}
\caption{Algoritmo genético com reconexão de caminhos entre ótimos locais.}
\label{code:genetic+ls+pr}
     
     $\prod \longleftarrow$ um conjunto de permutações aleatórias geradas de tarefas\;
     Calcule os valores de \textit{fitness} de cada permutação\;
     \Enqto{$i < N$}{
          $\prod^{*} \longleftarrow$ melhores soluções de $\prod$ \Comment{Elitismo}\;

          $\prod^{*} \longleftarrow$ \textit{Mutação} na solução $\pi$\;
          
          $\prod^{*} \longleftarrow$ \textit{Cruzamento} usando as soluções $\pi$ e $\theta$\;
          
          $\prod^{*} \longleftarrow$ \textit{Cruzamento com Busca Local} usando as soluções $\pi$ e $\theta$\;

          $\pi^{*}$ e $\theta^{*}$ $\longleftarrow$ \textit{Cruzamento baseado em posição} em $\pi$ e $\theta$\;
          
          \Para{cada filho $\pi^{*}$ e $\theta^{*}$}{
               Aplique movimentos GPI em $\pi^{*}$ e em $\theta^{*}$, até que não seja possível melhorar o valor de $\sum{\alpha_{j} E_{j}} + \sum{\beta_{j} T_{j}}$\;
          }
          
          \Se{$w(\pi^{*}) < w(\theta^{*})$}{
	          $\prod^{*} \longleftarrow$ \textbf{Reconexão-de-Caminhos}($\pi^{*}, \theta^{*}$)\;
	      }
	      \Senao{
	          $\prod^{*} \longleftarrow$ \textbf{Reconexão-de-Caminhos}($\theta^{*}, \pi^{*}$)\;
	      }
          $i \longleftarrow i + 1$\;
     }
     Retorne a melhor solução encontrada.

\end{algorithm}


O algoritmo genético com busca local é também conhecido como algoritmo memético, mas neste trabalho é chamado de "algoritmo genético híbrido" cuja estratégia de seleção de indivíduos utilizada foi a seleção por torneio, para as operações genéticas de mutação e cruzamento. O valor de função objetivo para o problema de escalonamento com antecipação e atraso ponderados ($\sum{\alpha_{j}E_{j}} + \sum{\beta_{j}T_{j}}$) foi utilizado como valor de \textit{fitness}.


\section{Algoritmo ILS busca múltipla - ILS-M} \label{sec:ILS-M}

O quinto e último método proposto envolve busca múltipla (multi-start) incluindo Busca Local como estratégia de melhoria. A diferença entre este algoritmo e o ILS (apresentado na seção \ref{sec:ILS}) é que este método considera um conjunto de soluções iniciais do espaço de busca, que são obtidas através de uma permutação de tarefas. Dessa forma, em cada iteração do algoritmo, tem-se um conjunto diferente de soluções onde dois passos são considerados. O primeiro passo dedica-se em construir novas soluções através da aplicação de perturbações em algumas soluções randomicamente selecionadas do conjunto corrente de soluções do algoritmo, com o objetivo de explorar a maior parte possível do espaço de soluções. O segundo passo dedica-se em melhorar as soluções obtidas através da aplicação de Busca Local em algumas soluções randomicamente escolhidas do conjunto de soluções da iteração corrente. Através desta abordagem é possível atingir melhores soluções que os outros métodos propostos. O Algoritmo~\ref{alg:ILS-Multi-start} apresenta a estratégia proposta, onde $x$ e $y$ são constantes, $N$ é o número de iterações e $\prod$ representa o conjunto de soluções utilizado em cada iteração. A Figura~\ref{fig:ILS-multi-start} ilustra a ideia proposta.

\begin{algorithm}
\caption{Algoritmo ILS busca múltipla.}
\label{alg:ILS-Multi-start}

   $i \leftarrow 1$\; % \Comment{Write a comment here}
   $\prod \longleftarrow$ um conjunto de permutações aleatórias de tarefas\; 
   Calcule o valor de função objetivo de cada sequência no conjunto\;
   \Enqto{$i < N$}{
      $\prod \longleftarrow$ permutações aleatórias em $x$ soluções randomicamente selecionadas\;
      $\prod \longleftarrow$ movimentos GPI em $y$ soluções randomicamente selecionadas até que nenhuma melhoria seja possível\;
      $i \leftarrow i + 1$;
   }
   Retorne a melhor solução encontrada.

\end{algorithm}


\begin{figure}[ht]
\centering
\includegraphics[width=.95\textwidth]{./imagens/ILS-M-1.eps}
\caption{Estratégia utilizada no algoritmo ILS busca múltipla.}
\label{fig:ILS-multi-start}
\end{figure}


\section{Branch-and-cut via CPLEX} \label{sec:BC}

Para o método exato, foi considerado o algoritmo \textit{branch-and-cut} do CPLEX, que será utilizado para fins de comparação com os métodos aproximados desenvolvidos. Para isso, foi implementado um programa em C++ que efetua a conversão de uma determinada instância para um arquivo em formato conhecido pelo CPLEX, como o formato LP, ou seja, o algoritmo desenvolvido gera o modelo a ser resolvido pelo CPLEX com o auxílio da ferramenta de programação matemática UFFLP~\cite{ArturEduardo:2011}, o Apêndice~\ref{apendice-UFFLP} apresenta maiores detalhes sobre esta biblioteca assim como a sua utilização. No Apêndice~\ref{apendice-CPLEX} é apresentada a ferramenta CPLEX juntamente com a sua estratégia algorítmica e um exemplo de saída do algoritmo para uma dada instância de exemplo.


\section{Considerações finais}

Neste capítulo foram detalhadas cinco estratégias algorítmicas aproximadas para o problema de escalonamento de tarefas que envolve penalidades de antecipação e atraso, para os ambientes mono e multiprocessado. Estas estratégias são baseadas em otimização global com busca simples (\textit{single-start}) ou busca múltipla (\textit{multi-start}) e baseadas em busca local com reconexão de caminhos. 

Os métodos apresentados neste capítulo foram: \textit{busca local iterada}, \textit{busca local iterada com reconexão de caminhos entre soluções ótimas locais}, \textit{algoritmo genético com reconexão de caminhos entre soluções arbitrárias}, \textit{algoritmo genético com reconexão de caminhos entre ótimos locais} e \textit{algoritmo de busca local iterada com busca múltipla}. Onde o objetivo dos métodos propostos foi analisar o processo de convergência, tempo de execução e a qualidade das soluções obtidas, afim de se atingir as melhores soluções possíveis. O método exato considerado foi o algoritmo \textit{branch-and-cut} via CPLEX. Os resultados obtidos através da execução dos métodos foram reportados no Capítulo~\ref{chap-ResComp}. 